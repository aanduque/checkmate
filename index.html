
<!DOCTYPE html>
<html lang="en" :data-theme="settings.theme || 'light'">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Check Mate - ADHD Task Manager</title>

  <!-- daisyUI + Tailwind CSS v4 -->
  <link href="https://cdn.jsdelivr.net/npm/daisyui@5" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/daisyui@5/themes.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>

  <!-- Custom theme colors -->
  <style type="text/tailwindcss">
    @theme {
      --color-on-track: #22c55e;
      --color-at-risk: #eab308;
      --color-off-track: #ef4444;
    }
  </style>

  <!-- RRule for recurrence -->
  <script src="https://cdn.jsdelivr.net/npm/rrule@2.8.1/dist/es5/rrule.min.js"></script>

  <!-- Filtrex for safe expression evaluation -->
  <script src="https://cdn.jsdelivr.net/npm/filtrex@3.1.0/dist/browser/filtrex.min.js"></script>

  <!-- Alpine Plugins -->
  <script defer src="https://cdn.jsdelivr.net/npm/@alpinejs/persist@3/dist/cdn.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/@alpinejs/sort@3/dist/cdn.min.js"></script>

  <!-- Alpine.js -->
  <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js"></script>

  <!-- Ionicons -->
  <script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"></script>
  <script nomodule src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js"></script>

  <style>
    /* Ionicons sizing */
    ion-icon { font-size: 1.25rem; }
    [x-cloak] { display: none !important; }
    .task-card { transition: all 0.2s ease; }
    .task-card:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
    .health-pulse { animation: pulse 2s infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    .line-clamp-2 { display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    /* Drag and drop styles */
    .sortable-ghost { opacity: 0.4; }
    .sortable-drag { box-shadow: 0 10px 20px rgba(0,0,0,0.15); }
    .sortable-chosen { cursor: grabbing; }
  </style>
</head>
<body class="bg-base-200 min-h-screen" x-cloak x-data="checkMate()" x-init="init()">
  
  <div class="max-w-7xl mx-auto p-4">
    
    <!-- Header -->
    <div class="navbar bg-base-100 rounded-box shadow-sm mb-6">
      <div class="navbar-start gap-3">
        <ion-icon name="checkbox-outline" class="text-3xl text-primary"></ion-icon>
        <div>
          <h1 class="text-xl font-bold">Check Mate</h1>
          <p class="text-xs opacity-70">ADHD-Focused Task Management</p>
        </div>
      </div>

      <div class="navbar-end gap-2 flex-wrap">
        <!-- Active Routine Indicator -->
        <template x-if="activeRoutine">
          <div class="badge badge-lg gap-1" :style="{ backgroundColor: activeRoutine.color + '20', color: activeRoutine.color, borderColor: activeRoutine.color }">
            <span x-text="activeRoutine.icon"></span>
            <span x-text="activeRoutine.name"></span>
            <button @click="clearRoutineOverride()" class="ml-1 opacity-60 hover:opacity-100" title="Clear override"><ion-icon name="close-outline" class="text-sm"></ion-icon></button>
          </div>
        </template>

        <!-- Manual Routine Selector -->
        <select x-model="manualRoutineId" class="select select-bordered select-sm">
          <option value="">Auto Routine</option>
          <template x-for="routine in routines" :key="routine.id">
            <option :value="routine.id" x-text="routine.icon + ' ' + routine.name"></option>
          </template>
        </select>

        <!-- Current Date -->
        <div class="text-sm opacity-70" x-text="formatDate(today)"></div>

        <!-- Theme Toggle -->
        <label class="swap swap-rotate btn btn-ghost btn-circle">
          <input type="checkbox" :checked="settings.theme === 'dark'" @change="settings.theme = $event.target.checked ? 'dark' : 'light'" />
          <ion-icon name="sunny-outline" class="swap-off text-xl"></ion-icon>
          <ion-icon name="moon-outline" class="swap-on text-xl"></ion-icon>
        </label>

        <!-- Action Buttons -->
        <button @click="showTagsModal = true" class="btn btn-ghost btn-circle" title="Manage Tags"><ion-icon name="pricetag-outline"></ion-icon></button>
        <button @click="showRoutinesModal = true" class="btn btn-ghost btn-circle" title="Manage Routines"><ion-icon name="sync-outline"></ion-icon></button>
        <button @click="showSettingsModal = true" class="btn btn-ghost btn-circle" title="Settings"><ion-icon name="settings-outline"></ion-icon></button>
      </div>
    </div>
    
    <!-- Active Session Banner -->
    <template x-if="activeSession">
      <div class="alert alert-info shadow-lg mb-6">
        <ion-icon name="radio-button-on-outline" class="text-4xl animate-pulse"></ion-icon>
        <div>
          <p class="text-sm opacity-80">Focusing on</p>
          <p class="font-bold text-lg" x-text="getTaskById(activeSession.taskId)?.title"></p>
        </div>
        <div class="text-center">
          <p class="text-3xl font-mono font-bold" x-text="formatSessionTime(sessionElapsed)"></p>
          <p class="text-xs opacity-80">elapsed</p>
        </div>
        <div class="flex gap-2">
          <button @click="openCompleteSessionModal()" class="btn btn-success btn-sm gap-1"><ion-icon name="checkmark-outline"></ion-icon> Complete</button>
          <button @click="abandonSession()" class="btn btn-ghost btn-sm gap-1"><ion-icon name="close-outline"></ion-icon> Abandon</button>
        </div>
      </div>
    </template>

    <!-- Main Navigation Tabs -->
    <div role="tablist" class="tabs tabs-boxed bg-base-100 mb-6 p-1">
      <button @click="currentView = 'sprint'" role="tab" :class="{'tab-active': currentView === 'sprint'}" class="tab gap-1">
        <ion-icon name="calendar-outline"></ion-icon> Sprints
      </button>
      <button @click="currentView = 'backlog'" role="tab" :class="{'tab-active': currentView === 'backlog'}" class="tab gap-1">
        <ion-icon name="clipboard-outline"></ion-icon> Backlog <span class="badge badge-sm" x-text="backlogTasks.length"></span>
      </button>
      <button @click="currentView = 'recurring'" role="tab" :class="{'tab-active': currentView === 'recurring'}" class="tab gap-1">
        <ion-icon name="repeat-outline"></ion-icon> Recurring <span class="badge badge-sm" x-text="recurringTemplates.length"></span>
      </button>
      <button @click="currentView = 'completed'" role="tab" :class="{'tab-active': currentView === 'completed'}" class="tab gap-1">
        <ion-icon name="checkmark-circle-outline"></ion-icon> Completed <span class="badge badge-sm" x-text="completedTasks.length"></span>
      </button>
    </div>
    
    <!-- Tag Filter Bar -->
    <div class="card bg-base-100 shadow-sm mb-6">
      <div class="card-body p-4 flex-row items-center gap-4 flex-wrap">
        <div class="flex items-center gap-2 flex-wrap">
          <span class="text-sm opacity-70">Filter:</span>
          <button @click="toggleTagFilter(null)"
                  :class="selectedTagFilters.length === 0 ? 'btn-neutral' : 'btn-ghost'"
                  class="btn btn-xs">All</button>
          <template x-for="tag in tags" :key="tag.id">
            <button @click="toggleTagFilter(tag.id)"
                    :class="selectedTagFilters.includes(tag.id) ? 'ring-2 ring-offset-1' : ''"
                    :style="{ backgroundColor: tag.color + '20', color: tag.color, '--tw-ring-color': tag.color }"
                    class="btn btn-xs gap-1">
              <span x-text="tag.icon"></span>
              <span x-text="tag.name"></span>
            </button>
          </template>
        </div>
        <div class="flex-1"></div>
        <button @click="showCreateTaskModal = true" class="btn btn-primary btn-sm gap-1">
          <ion-icon name="add-outline"></ion-icon> New Task
        </button>
      </div>
    </div>
    
    <!-- ==================== SPRINT VIEW ==================== -->
    <div x-show="currentView === 'sprint'" class="space-y-6">
      <!-- Sprint Tabs -->
      <div role="tablist" class="tabs tabs-boxed bg-base-100 p-1 w-fit">
        <template x-for="(sprint, index) in sprints" :key="sprint.id">
          <button @click="selectedSprintIndex = index" role="tab" :class="{'tab-active': selectedSprintIndex === index}" class="tab gap-2">
            <ion-icon :name="getSprintIcon(index)"></ion-icon>
            <span x-text="getSprintLabel(index)"></span>
            <span class="badge badge-sm"
                  :class="{
                    'badge-success': getSprintHealth(sprint).overall === 'on_track',
                    'badge-warning': getSprintHealth(sprint).overall === 'at_risk',
                    'badge-error': getSprintHealth(sprint).overall === 'off_track'
                  }"
                  x-text="getSprintHealth(sprint).overall.replace('_', ' ')"></span>
          </button>
        </template>
      </div>

      <!-- Sprint Content -->
      <template x-if="selectedSprint">
        <div class="card bg-base-100 shadow-sm">
          <div class="card-body">
            <!-- Sprint Header -->
            <div class="flex items-start justify-between flex-wrap gap-4">
              <div>
                <h2 class="card-title gap-2"><ion-icon :name="getSprintIcon(selectedSprintIndex)"></ion-icon> <span x-text="getSprintLabel(selectedSprintIndex)"></span></h2>
                <p class="text-sm opacity-70">
                  <span x-text="formatDate(selectedSprint.startDate)"></span> -
                  <span x-text="formatDate(selectedSprint.endDate)"></span>
                  <span class="ml-2 font-medium">(<span x-text="getDaysRemaining(selectedSprint)"></span> days left)</span>
                </p>
              </div>
              <button @click="showSprintHealthModal = true" class="btn btn-ghost btn-sm">View health details</button>
            </div>
          
            <!-- Capacity Cards -->
            <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-3 my-4">
              <template x-for="tag in tags" :key="tag.id">
                <div class="bg-base-200 rounded-lg p-3">
                  <div class="flex items-center gap-2 mb-2">
                    <span x-text="tag.icon"></span>
                    <span class="text-sm font-medium truncate" x-text="tag.name"></span>
                  </div>
                  <div class="flex justify-between text-xs opacity-70">
                    <span>Used:</span>
                    <span x-text="getSprintPointsForTag(selectedSprint, tag.id) + '/' + getCapacityForTag(selectedSprint, tag.id) + ' pts'"></span>
                  </div>
                  <progress class="progress mt-2"
                       :class="{
                         'progress-success': getSprintPointsForTag(selectedSprint, tag.id) / getCapacityForTag(selectedSprint, tag.id) <= 0.8,
                         'progress-warning': getSprintPointsForTag(selectedSprint, tag.id) / getCapacityForTag(selectedSprint, tag.id) > 0.8 && getSprintPointsForTag(selectedSprint, tag.id) / getCapacityForTag(selectedSprint, tag.id) <= 1,
                         'progress-error': getSprintPointsForTag(selectedSprint, tag.id) / getCapacityForTag(selectedSprint, tag.id) > 1
                       }"
                       :value="getSprintPointsForTag(selectedSprint, tag.id)"
                       :max="getCapacityForTag(selectedSprint, tag.id)"></progress>
                  <button @click="editSprintCapacity(selectedSprint, tag)" class="btn btn-ghost btn-xs mt-1">Edit</button>
                </div>
              </template>
            </div>

            <!-- Sprint Tasks -->
            <div class="space-y-3" x-sort="handleTaskReorder">
              <template x-for="task in getSprintTasks(selectedSprint)" :key="task.id">
                <div x-sort:item="task.id"
                     class="card bg-base-200 border-l-4 cursor-grab active:cursor-grabbing"
                     :class="{
                       'opacity-60': task.skipState?.type === 'for_day' && !task.skipState?.returned,
                       'border-l-warning bg-warning/10': task.skipState?.type === 'for_now',
                       'border-l-info bg-info/10': task.skipState?.type === 'for_day' && task.skipState?.returned
                     }"
                     :style="!task.skipState ? { borderLeftColor: getTaskPrimaryTag(task)?.color || 'oklch(var(--bc)/0.2)' } : {}">
                  <div class="card-body p-4">
                    <div class="flex items-start justify-between gap-4">
                      <div class="flex items-center gap-2 opacity-40 cursor-grab" x-sort:handle><ion-icon name="reorder-three-outline"></ion-icon></div>
                      <div class="flex-1 min-w-0">
                        <div class="flex items-center gap-2 mb-1 flex-wrap">
                          <h3 class="font-medium" x-text="task.title"></h3>
                          <template x-if="task.parentId">
                            <span class="badge badge-secondary badge-sm gap-1"><ion-icon name="repeat-outline"></ion-icon> instance</span>
                          </template>
                          <template x-if="task.skipState?.type === 'for_now'">
                            <span class="badge badge-warning badge-sm gap-1"><ion-icon name="play-skip-forward-outline"></ion-icon> Skipped</span>
                          </template>
                          <template x-if="task.skipState?.type === 'for_day' && task.skipState?.returned">
                            <span class="badge badge-info badge-sm gap-1"><ion-icon name="arrow-undo-outline"></ion-icon> Returned!</span>
                          </template>
                        </div>
                        <div class="flex flex-wrap gap-1.5 mb-2">
                          <template x-for="(points, tagId) in task.tagPoints" :key="tagId">
                            <span class="badge badge-sm" :style="{ backgroundColor: getTagById(tagId)?.color + '20', color: getTagById(tagId)?.color, borderColor: getTagById(tagId)?.color }">
                              <span x-text="getTagById(tagId)?.icon"></span>
                              <span x-text="getTagById(tagId)?.name"></span>
                              <span class="font-bold" x-text="points + 'pt'"></span>
                            </span>
                          </template>
                        </div>
                        <div class="flex items-center gap-3 text-xs opacity-60">
                          <span x-text="getTaskAge(task) + 'd old'"></span>
                          <span x-text="(task.sessions?.length || 0) + ' sessions'"></span>
                          <span x-text="(task.comments?.length || 0) + ' comments'"></span>
                        </div>
                      </div>
                      <div class="flex items-center gap-1">
                        <button @click="startSession(task)" :disabled="activeSession" class="btn btn-ghost btn-circle btn-sm text-success" title="Start Session"><ion-icon name="play-outline"></ion-icon></button>
                        <button @click="openTaskDetail(task)" class="btn btn-ghost btn-circle btn-sm" title="Details"><ion-icon name="create-outline"></ion-icon></button>
                        <div class="dropdown dropdown-end">
                          <div tabindex="0" role="button" class="btn btn-ghost btn-circle btn-sm"><ion-icon name="ellipsis-vertical-outline"></ion-icon></div>
                          <ul tabindex="0" class="dropdown-content menu bg-base-100 rounded-box z-20 w-48 p-2 shadow-lg">
                            <template x-if="task.skipState">
                              <li><a @click="clearSkipState(task)" class="gap-2"><ion-icon name="arrow-undo-outline"></ion-icon> Clear skip</a></li>
                            </template>
                            <li><a @click="skipTaskForNow(task)" class="gap-2"><ion-icon name="play-skip-forward-outline"></ion-icon> Skip for now</a></li>
                            <li><a @click="openSkipForDayModal(task)" class="gap-2"><ion-icon name="calendar-outline"></ion-icon> Skip for day</a></li>
                            <li><a @click="completeTask(task)" class="gap-2 text-success"><ion-icon name="checkmark-circle-outline"></ion-icon> Complete</a></li>
                            <li><a @click="moveTaskToBacklog(task)" class="gap-2"><ion-icon name="clipboard-outline"></ion-icon> To Backlog</a></li>
                            <li><a @click="cancelTask(task)" class="gap-2 text-error"><ion-icon name="trash-outline"></ion-icon> Cancel</a></li>
                          </ul>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </template>
              <template x-if="getSprintTasks(selectedSprint).length === 0">
                <div class="text-center py-12 opacity-60">
                  <ion-icon name="mail-open-outline" class="text-4xl mb-2"></ion-icon>
                  <p>No tasks in this sprint</p>
                  <p class="text-sm">Move tasks from the backlog or create new ones</p>
                </div>
              </template>
            </div>
          </div>
        </div>
      </template>
    </div>
    
    <!-- ==================== BACKLOG VIEW ==================== -->
    <div x-show="currentView === 'backlog'" class="card bg-base-100 shadow-sm">
      <div class="card-body">
        <div class="flex items-center justify-between mb-4">
          <h2 class="card-title">Backlog</h2>
          <span class="badge badge-ghost" x-text="filteredBacklogTasks.length + ' tasks'"></span>
        </div>
        <div class="space-y-3">
          <template x-for="task in filteredBacklogTasks" :key="task.id">
            <div class="card bg-base-200 border-l-4" :style="{ borderLeftColor: getTaskPrimaryTag(task)?.color || 'oklch(var(--bc)/0.2)' }">
              <div class="card-body p-4">
                <div class="flex items-start justify-between gap-4">
                  <div class="flex-1 min-w-0">
                    <div class="flex items-center gap-2 mb-1 flex-wrap">
                      <h3 class="font-medium" x-text="task.title"></h3>
                      <template x-if="task.parentId">
                        <span class="badge badge-secondary badge-sm gap-1"><ion-icon name="repeat-outline"></ion-icon> instance</span>
                      </template>
                    </div>
                    <template x-if="task.description">
                      <p class="text-sm opacity-70 mb-2 line-clamp-2" x-text="task.description"></p>
                    </template>
                    <div class="flex flex-wrap gap-1.5 mb-2">
                      <template x-for="(points, tagId) in task.tagPoints" :key="tagId">
                        <span class="badge badge-sm" :style="{ backgroundColor: getTagById(tagId)?.color + '20', color: getTagById(tagId)?.color, borderColor: getTagById(tagId)?.color }">
                          <span x-text="getTagById(tagId)?.icon"></span>
                          <span x-text="getTagById(tagId)?.name"></span>
                          <span class="font-bold" x-text="points + 'pt'"></span>
                        </span>
                      </template>
                    </div>
                    <div class="flex items-center gap-3 text-xs opacity-60">
                      <span x-text="getTaskAge(task) + 'd old'"></span>
                      <span x-text="'In ' + (task.sprintHistory?.length || 0) + ' sprints'"></span>
                    </div>
                  </div>
                  <div class="flex items-center gap-1">
                    <div class="dropdown dropdown-end">
                      <div tabindex="0" role="button" class="btn btn-primary btn-sm gap-1">Move <ion-icon name="chevron-down-outline"></ion-icon></div>
                      <ul tabindex="0" class="dropdown-content menu bg-base-100 rounded-box z-20 w-48 p-2 shadow-lg">
                        <template x-for="(sprint, index) in sprints" :key="sprint.id">
                          <li><a @click="moveTaskToSprint(task, sprint)" class="gap-2"><ion-icon :name="getSprintIcon(index)"></ion-icon> <span x-text="getSprintLabel(index)"></span></a></li>
                        </template>
                      </ul>
                    </div>
                    <button @click="openTaskDetail(task)" class="btn btn-ghost btn-circle btn-sm" title="Details"><ion-icon name="create-outline"></ion-icon></button>
                    <button @click="cancelTask(task)" class="btn btn-ghost btn-circle btn-sm text-error" title="Cancel"><ion-icon name="trash-outline"></ion-icon></button>
                  </div>
                </div>
              </div>
            </div>
          </template>
          <template x-if="filteredBacklogTasks.length === 0">
            <div class="text-center py-12 opacity-60">
              <ion-icon name="trophy-outline" class="text-4xl mb-2"></ion-icon>
              <p>Backlog is empty!</p>
              <p class="text-sm">Create new tasks or check your filters</p>
            </div>
          </template>
        </div>
      </div>
    </div>

    <!-- ==================== RECURRING VIEW ==================== -->
    <div x-show="currentView === 'recurring'" class="card bg-base-100 shadow-sm">
      <div class="card-body">
        <div class="flex items-center justify-between mb-4 flex-wrap gap-4">
          <div>
            <h2 class="card-title">Recurring Templates</h2>
            <p class="text-sm opacity-70">Templates spawn task instances based on their schedule</p>
          </div>
          <button @click="showCreateTaskModal = true" class="btn btn-secondary btn-sm gap-1">
            <ion-icon name="add-outline"></ion-icon> New Recurring
          </button>
        <div class="space-y-3">
          <template x-for="template in recurringTemplates" :key="template.id">
            <div class="card bg-base-200 border-l-4 border-l-secondary">
              <div class="card-body p-4">
                <div class="flex items-start justify-between gap-4">
                  <div class="flex-1 min-w-0">
                    <div class="flex items-center gap-2 mb-1">
                      <ion-icon name="repeat-outline" class="text-lg text-secondary"></ion-icon>
                      <h3 class="font-medium" x-text="template.title"></h3>
                    </div>
                    <p class="text-sm text-secondary mb-2" x-text="describeRRule(template.recurrence)"></p>
                    <div class="flex flex-wrap gap-1.5 mb-2">
                      <template x-for="(points, tagId) in template.tagPoints" :key="tagId">
                        <span class="badge badge-sm" :style="{ backgroundColor: getTagById(tagId)?.color + '20', color: getTagById(tagId)?.color, borderColor: getTagById(tagId)?.color }">
                          <span x-text="getTagById(tagId)?.icon"></span>
                          <span x-text="getTagById(tagId)?.name"></span>
                          <span class="font-bold" x-text="points + 'pt'"></span>
                        </span>
                      </template>
                    </div>
                    <div class="text-xs opacity-60">
                      Next: <span x-text="formatDate(getNextOccurrence(template))"></span>
                    </div>
                  </div>
                  <div class="flex items-center gap-1">
                    <button @click="spawnRecurringInstance(template)" class="btn btn-secondary btn-sm">Spawn Now</button>
                    <button @click="openTaskDetail(template)" class="btn btn-ghost btn-circle btn-sm"><ion-icon name="create-outline"></ion-icon></button>
                    <button @click="cancelTask(template)" class="btn btn-ghost btn-circle btn-sm text-error"><ion-icon name="trash-outline"></ion-icon></button>
                  </div>
                </div>
              </div>
            </div>
          </template>
          <template x-if="recurringTemplates.length === 0">
            <div class="text-center py-12 opacity-60">
              <ion-icon name="repeat-outline" class="text-4xl mb-2"></ion-icon>
              <p>No recurring templates</p>
              <p class="text-sm">Create recurring tasks for regular activities</p>
            </div>
          </template>
        </div>
      </div>
    </div>

    <!-- ==================== COMPLETED VIEW ==================== -->
    <div x-show="currentView === 'completed'" class="card bg-base-100 shadow-sm">
      <div class="card-body">
        <div class="flex items-center justify-between mb-4">
          <h2 class="card-title">Completed & Canceled</h2>
          <span class="badge badge-ghost" x-text="completedTasks.length + ' tasks'"></span>
        </div>
        <div class="space-y-3">
          <template x-for="task in completedTasks" :key="task.id">
            <div class="card bg-base-200 border-l-4" :class="task.status === 'completed' ? 'border-l-success' : 'border-l-error'">
              <div class="card-body p-4">
                <div class="flex items-start justify-between gap-4">
                  <div class="flex-1 min-w-0">
                    <div class="flex items-center gap-2 mb-1">
                      <ion-icon :name="task.status === 'completed' ? 'checkmark-circle-outline' : 'close-circle-outline'" :class="task.status === 'completed' ? 'text-success' : 'text-error'"></ion-icon>
                      <h3 class="font-medium opacity-50 line-through" x-text="task.title"></h3>
                    </div>
                    <div class="flex flex-wrap gap-1.5">
                      <template x-for="(points, tagId) in task.tagPoints" :key="tagId">
                        <span class="badge badge-sm opacity-60" :style="{ backgroundColor: getTagById(tagId)?.color + '20', color: getTagById(tagId)?.color, borderColor: getTagById(tagId)?.color }">
                          <span x-text="getTagById(tagId)?.icon"></span>
                          <span class="font-bold" x-text="points + 'pt'"></span>
                        </span>
                      </template>
                    </div>
                  </div>
                  <button @click="openTaskDetail(task)" class="btn btn-ghost btn-circle btn-sm"><ion-icon name="create-outline"></ion-icon></button>
                </div>
              </div>
            </div>
          </template>
          <template x-if="completedTasks.length === 0">
            <div class="text-center py-12 opacity-60">
              <ion-icon name="hourglass-outline" class="text-4xl mb-2"></ion-icon>
              <p>No completed tasks yet</p>
            </div>
          </template>
        </div>
      </div>
    </div>

  </div>
  
  <!-- ==================== MODALS ==================== -->

  <!-- Create Task Modal -->
  <dialog x-ref="createTaskModal" class="modal" :class="{'modal-open': showCreateTaskModal}">
    <div class="modal-box">
      <form method="dialog">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" @click="showCreateTaskModal = false">âœ•</button>
      </form>
      <h3 class="text-lg font-bold mb-4">Create New Task</h3>
      <form @submit.prevent="createTask()">
        <div class="space-y-4">
          <div class="form-control">
            <label class="label"><span class="label-text">Title *</span></label>
            <input type="text" x-model="newTask.title" required class="input input-bordered w-full" placeholder="What needs to be done?">
          </div>
          <div class="form-control">
            <label class="label"><span class="label-text">Description</span></label>
            <textarea x-model="newTask.description" rows="3" class="textarea textarea-bordered w-full" placeholder="Additional details"></textarea>
          </div>
          <div class="form-control">
            <label class="label"><span class="label-text">Points per Tag *</span></label>
            <div class="space-y-2">
              <template x-for="tag in tags" :key="tag.id">
                <div class="flex items-center gap-3">
                  <div class="flex items-center gap-2 w-32" :style="{ color: tag.color }">
                    <span x-text="tag.icon"></span>
                    <span x-text="tag.name"></span>
                  </div>
                  <select x-model="newTask.tagPoints[tag.id]" class="select select-bordered select-sm">
                    <option value="">-</option>
                    <template x-for="pt in FIBONACCI_POINTS" :key="pt">
                      <option :value="pt" x-text="pt + ' pt'"></option>
                    </template>
                  </select>
                </div>
              </template>
            </div>
            <label class="label"><span class="label-text-alt">Select at least one tag with points</span></label>
          </div>
          <!-- Recurrence preview -->
          <template x-if="parseRecurrence(newTask.title).valid">
            <div class="alert alert-info py-2">
              <ion-icon name="repeat-outline"></ion-icon>
              <span>Repeats <span x-text="parseRecurrence(newTask.title).description"></span></span>
            </div>
          </template>
        </div>
        <div class="modal-action">
          <button type="button" @click="showCreateTaskModal = false" class="btn btn-ghost">Cancel</button>
          <button type="submit" class="btn btn-primary" x-text="parseRecurrence(newTask.title).valid ? 'Create Recurring Task' : 'Create Task'"></button>
        </div>
      </form>
    </div>
    <form method="dialog" class="modal-backdrop" @click="showCreateTaskModal = false"><button>close</button></form>
  </dialog>

  <!-- Task Detail Modal -->
  <dialog x-ref="taskDetailModal" class="modal" :class="{'modal-open': showTaskDetailModal}">
    <div class="modal-box max-w-2xl">
      <form method="dialog">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" @click="showTaskDetailModal = false; saveTaskDetail()">âœ•</button>
      </form>
      <template x-if="selectedTask">
        <div>
          <div class="flex items-start gap-2 mb-4">
            <ion-icon x-show="selectedTask.status === 'completed'" name="checkmark-circle-outline" class="text-success text-xl mt-1"></ion-icon>
            <ion-icon x-show="selectedTask.status === 'canceled'" name="close-circle-outline" class="text-error text-xl mt-1"></ion-icon>
            <ion-icon x-show="selectedTask.recurrence" name="repeat-outline" class="text-secondary text-xl mt-1"></ion-icon>
            <div class="flex-1">
              <input type="text" x-model="selectedTask.title" @change="saveTaskDetail()"
                     class="input input-ghost text-xl font-bold w-full p-0 h-auto focus:bg-base-200"
                     :disabled="selectedTask.status !== 'active'">
              <div class="flex items-center gap-2 text-sm opacity-60 mt-1">
                <span x-text="'Created ' + formatDate(new Date(selectedTask.createdAt))"></span>
                <span>â€¢</span>
                <span x-text="getTaskAge(selectedTask) + ' days old'"></span>
              </div>
            </div>
          </div>

          <!-- Description -->
          <div class="form-control mb-6">
            <label class="label"><span class="label-text">Description</span></label>
            <textarea x-model="selectedTask.description" @change="saveTaskDetail()" rows="3"
                      class="textarea textarea-bordered w-full" placeholder="Add description..."
                      :disabled="selectedTask.status !== 'active'"></textarea>
          </div>

          <!-- Tags & Points -->
          <div class="mb-6">
            <label class="label"><span class="label-text">Tags & Points</span></label>
            <div class="flex flex-wrap gap-2">
              <template x-for="(points, tagId) in selectedTask.tagPoints" :key="tagId">
                <div class="badge badge-lg gap-1" :style="{ backgroundColor: getTagById(tagId)?.color + '20', color: getTagById(tagId)?.color, borderColor: getTagById(tagId)?.color }">
                  <span x-text="getTagById(tagId)?.icon"></span>
                  <span x-text="getTagById(tagId)?.name"></span>
                  <select x-model="selectedTask.tagPoints[tagId]" @change="saveTaskDetail()"
                          class="bg-transparent border-none text-sm font-bold w-14"
                          :disabled="selectedTask.status !== 'active'">
                    <template x-for="pt in FIBONACCI_POINTS" :key="pt">
                      <option :value="pt" x-text="pt + 'pt'"></option>
                    </template>
                  </select>
                </div>
              </template>
            </div>
          </div>
          
          <!-- Recurrence Info -->
          <template x-if="selectedTask.recurrence">
            <div class="mb-6 p-4 bg-secondary/10 rounded-lg">
              <label class="block text-sm font-medium text-secondary mb-1 flex items-center gap-1"><ion-icon name="repeat-outline"></ion-icon> Recurrence Pattern</label>
              <p class="text-secondary" x-text="describeRRule(selectedTask.recurrence)"></p>
              <p class="text-xs opacity-70 mt-1">Next: <span x-text="formatDate(getNextOccurrence(selectedTask))"></span></p>
            </div>
          </template>
          
          <!-- Sessions -->
          <div class="mb-6">
            <div class="flex items-center justify-between mb-2">
              <label class="label-text font-medium">Focus Sessions</label>
              <button @click="startSession(selectedTask); showTaskDetailModal = false"
                      :disabled="activeSession || selectedTask.status !== 'active'"
                      class="btn btn-ghost btn-xs text-primary">+ Start Session</button>
            </div>
            <div class="space-y-2 max-h-40 overflow-y-auto">
              <template x-for="session in (selectedTask.sessions || []).slice().reverse()" :key="session.id">
                <div class="bg-base-200 rounded-lg p-3 text-sm">
                  <div class="flex items-center justify-between">
                    <div class="flex items-center gap-2">
                      <ion-icon :class="{'text-success': session.status === 'completed', 'text-error': session.status === 'abandoned', 'text-info': session.status === 'in_progress'}"
                            :name="session.status === 'completed' ? 'checkmark-outline' : session.status === 'abandoned' ? 'close-outline' : 'play-outline'"></ion-icon>
                      <span x-text="formatDate(new Date(session.startedAt))"></span>
                      <template x-if="session.endedAt">
                        <span class="opacity-60" x-text="'(' + formatSessionTime(Math.floor((new Date(session.endedAt) - new Date(session.startedAt)) / 1000)) + ')'"></span>
                      </template>
                    </div>
                    <template x-if="session.focusLevel">
                      <span class="badge badge-sm"
                            :class="{'badge-success': session.focusLevel === 'focused', 'badge-warning': session.focusLevel === 'neutral', 'badge-error': session.focusLevel === 'distracted'}"
                            x-text="session.focusLevel"></span>
                    </template>
                  </div>
                </div>
              </template>
              <template x-if="!selectedTask.sessions?.length">
                <p class="text-sm opacity-50 italic">No sessions yet</p>
              </template>
            </div>
          </div>
          
          <!-- Comments -->
          <div class="mb-6">
            <label class="label-text font-medium mb-2 block">Comments</label>
            <div class="space-y-2 mb-3 max-h-48 overflow-y-auto">
              <template x-for="comment in (selectedTask.comments || [])" :key="comment.id">
                <div class="bg-base-200 rounded-lg p-3" :class="comment.skipJustification ? 'border-l-4 border-l-warning' : ''">
                  <div class="flex items-start justify-between">
                    <div class="flex-1">
                      <template x-if="comment.skipJustification">
                        <span class="badge badge-warning badge-sm mb-1">Skip Justification</span>
                      </template>
                      <p class="text-sm whitespace-pre-wrap" x-text="comment.content"></p>
                      <p class="text-xs opacity-50 mt-1" x-text="formatDate(new Date(comment.createdAt))"></p>
                    </div>
                    <button @click="deleteComment(selectedTask, comment)" class="btn btn-ghost btn-xs text-error"><ion-icon name="trash-outline"></ion-icon></button>
                  </div>
                </div>
              </template>
            </div>
            <div class="flex gap-2">
              <input type="text" x-model="newCommentContent" @keyup.enter="addComment(selectedTask)"
                     class="input input-bordered input-sm flex-1" placeholder="Add a comment...">
              <button @click="addComment(selectedTask)" class="btn btn-ghost btn-sm">Add</button>
            </div>
          </div>
          
          <!-- Location & Parent -->
          <div class="text-sm opacity-70">
            <p class="flex items-center gap-1">Location: <span class="font-medium flex items-center gap-1"><ion-icon :name="selectedTask.location.type === 'backlog' ? 'clipboard-outline' : 'calendar-outline'"></ion-icon> <span x-text="selectedTask.location.type === 'backlog' ? 'Backlog' : 'Sprint'"></span></span></p>
            <template x-if="selectedTask.parentId">
              <p class="mt-1 flex items-center gap-1">
                <ion-icon name="repeat-outline"></ion-icon> Instance of:
                <span class="font-medium" x-text="getTaskById(selectedTask.parentId)?.title"></span>
              </p>
            </template>
          </div>
        </div>
      </template>
    </div>
    <form method="dialog" class="modal-backdrop" @click="showTaskDetailModal = false; saveTaskDetail()"><button>close</button></form>
  </dialog>
  
  <!-- Skip For Day Modal -->
  <dialog class="modal" :class="{'modal-open': showSkipForDayModal}">
    <div class="modal-box">
      <form method="dialog">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" @click="showSkipForDayModal = false">âœ•</button>
      </form>
      <h3 class="text-lg font-bold mb-2">Skip for Day</h3>
      <p class="opacity-70 mb-4">This task will be hidden until tomorrow. Please provide a justification.</p>
      <div class="form-control mb-4">
        <label class="label"><span class="label-text">Justification *</span></label>
        <textarea x-model="skipJustification" required rows="3" class="textarea textarea-bordered" placeholder="Why are you skipping this task?"></textarea>
      </div>
      <div class="modal-action">
        <button @click="showSkipForDayModal = false" class="btn btn-ghost">Cancel</button>
        <button @click="confirmSkipForDay()" :disabled="!skipJustification.trim()" class="btn btn-warning">Skip Task</button>
      </div>
    </div>
    <form method="dialog" class="modal-backdrop" @click="showSkipForDayModal = false"><button>close</button></form>
  </dialog>
  
  <!-- Complete Session Modal -->
  <dialog class="modal" :class="{'modal-open': showCompleteSessionModal}">
    <div class="modal-box">
      <form method="dialog">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" @click="showCompleteSessionModal = false">âœ•</button>
      </form>
      <h3 class="text-lg font-bold mb-4">Complete Session</h3>
      <div class="mb-4">
        <label class="label"><span class="label-text">How focused were you?</span></label>
        <div class="flex gap-2">
          <button type="button" @click="sessionFocusLevel = 'distracted'"
                  class="btn btn-sm flex-1" :class="sessionFocusLevel === 'distracted' ? 'btn-error' : 'btn-ghost bg-error/10 text-error'">
            <ion-icon name="sad-outline"></ion-icon> Distracted
          </button>
          <button type="button" @click="sessionFocusLevel = 'neutral'"
                  class="btn btn-sm flex-1" :class="sessionFocusLevel === 'neutral' ? 'btn-warning' : 'btn-ghost bg-warning/10 text-warning'">
            <ion-icon name="ellipse-outline"></ion-icon> Neutral
          </button>
          <button type="button" @click="sessionFocusLevel = 'focused'"
                  class="btn btn-sm flex-1" :class="sessionFocusLevel === 'focused' ? 'btn-success' : 'btn-ghost bg-success/10 text-success'">
            <ion-icon name="radio-button-on-outline"></ion-icon> Focused
          </button>
        </div>
      </div>
      <div class="form-control mb-4">
        <label class="label"><span class="label-text">Session Note (optional)</span></label>
        <textarea x-model="sessionNote" rows="2" class="textarea textarea-bordered" placeholder="What did you accomplish?"></textarea>
      </div>
      <div class="form-control mb-4">
        <label class="label cursor-pointer justify-start gap-2">
          <input type="checkbox" x-model="markTaskComplete" class="checkbox checkbox-sm">
          <span class="label-text">Also mark task as complete</span>
        </label>
      </div>
      <div class="modal-action">
        <button @click="showCompleteSessionModal = false" class="btn btn-ghost">Cancel</button>
        <button @click="confirmCompleteSession()" class="btn btn-success">Complete Session</button>
      </div>
    </div>
    <form method="dialog" class="modal-backdrop" @click="showCompleteSessionModal = false"><button>close</button></form>
  </dialog>
  
  <!-- Sprint Health Modal -->
  <dialog class="modal" :class="{'modal-open': showSprintHealthModal}">
    <div class="modal-box max-w-lg">
      <form method="dialog">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" @click="showSprintHealthModal = false">âœ•</button>
      </form>
      <h3 class="text-lg font-bold mb-4">Sprint Health Details</h3>
      <template x-if="selectedSprint">
        <div class="space-y-4">
          <template x-for="tag in tags" :key="tag.id">
            <div class="p-4 rounded-lg"
                 :class="{'bg-success/10': getTagHealth(selectedSprint, tag.id) === 'on_track', 'bg-warning/10': getTagHealth(selectedSprint, tag.id) === 'at_risk', 'bg-error/10': getTagHealth(selectedSprint, tag.id) === 'off_track'}">
              <div class="flex items-center justify-between mb-2">
                <div class="flex items-center gap-2">
                  <span x-text="tag.icon"></span>
                  <span class="font-medium" x-text="tag.name"></span>
                </div>
                <span class="badge"
                      :class="{'badge-success': getTagHealth(selectedSprint, tag.id) === 'on_track', 'badge-warning': getTagHealth(selectedSprint, tag.id) === 'at_risk', 'badge-error': getTagHealth(selectedSprint, tag.id) === 'off_track'}"
                      x-text="getTagHealth(selectedSprint, tag.id).replace('_', ' ')"></span>
              </div>
              <div class="grid grid-cols-2 gap-2 text-sm">
                <div><span class="opacity-60">Assigned:</span> <span class="font-medium" x-text="getSprintPointsForTag(selectedSprint, tag.id) + ' pts'"></span></div>
                <div><span class="opacity-60">Capacity:</span> <span class="font-medium" x-text="getCapacityForTag(selectedSprint, tag.id) + ' pts'"></span></div>
                <div><span class="opacity-60">Burn rate:</span> <span class="font-medium" x-text="getBurnRateNeeded(selectedSprint, tag.id).toFixed(1) + ' pts/day'"></span></div>
                <div><span class="opacity-60">Sustainable:</span> <span class="font-medium" x-text="(getCapacityForTag(selectedSprint, tag.id) / 7).toFixed(1) + ' pts/day'"></span></div>
              </div>
            </div>
          </template>
        </div>
      </template>
      <div class="modal-action">
        <button @click="showSprintHealthModal = false" class="btn btn-ghost">Close</button>
      </div>
    </div>
    <form method="dialog" class="modal-backdrop" @click="showSprintHealthModal = false"><button>close</button></form>
  </dialog>
  
  <!-- Capacity Edit Modal -->
  <dialog class="modal" :class="{'modal-open': showCapacityEditModal}">
    <div class="modal-box max-w-sm">
      <form method="dialog">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" @click="showCapacityEditModal = false">âœ•</button>
      </form>
      <h3 class="text-lg font-bold mb-4">Edit Capacity</h3>
      <template x-if="capacityEditTag">
        <div>
          <div class="flex items-center gap-2 mb-4" :style="{ color: capacityEditTag.color }">
            <span x-text="capacityEditTag.icon" class="text-2xl"></span>
            <span class="font-medium" x-text="capacityEditTag.name"></span>
          </div>
          <div class="form-control mb-4">
            <label class="label"><span class="label-text">Capacity for this sprint</span></label>
            <input type="number" x-model.number="capacityEditValue" min="1" class="input input-bordered">
            <label class="label"><span class="label-text-alt">Default: <span x-text="capacityEditTag.defaultCapacity"></span> points</span></label>
          </div>
          <div class="modal-action">
            <button @click="showCapacityEditModal = false" class="btn btn-ghost">Cancel</button>
            <button @click="saveCapacityOverride()" class="btn btn-primary">Save</button>
          </div>
        </div>
      </template>
    </div>
    <form method="dialog" class="modal-backdrop" @click="showCapacityEditModal = false"><button>close</button></form>
  </dialog>
  
  <!-- Tags Management Modal -->
  <dialog class="modal" :class="{'modal-open': showTagsModal}">
    <div class="modal-box max-w-lg max-h-[90vh]">
      <form method="dialog">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" @click="showTagsModal = false">âœ•</button>
      </form>
      <h3 class="text-lg font-bold mb-4">Manage Tags</h3>
      <div class="space-y-3 mb-6">
        <template x-for="tag in tags" :key="tag.id">
          <div class="flex items-center gap-3 p-3 bg-base-200 rounded-lg">
            <input type="text" x-model="tag.icon" @change="updateTag(tag)" class="input input-ghost w-12 text-center text-xl p-0">
            <div class="flex-1">
              <input type="text" x-model="tag.name" @change="updateTag(tag)" class="input input-ghost font-medium p-0 h-auto w-full" :style="{ color: tag.color }">
              <div class="flex items-center gap-2 mt-1">
                <input type="color" x-model="tag.color" @change="updateTag(tag)" class="w-6 h-6 rounded cursor-pointer">
                <span class="text-xs opacity-60">Cap:</span>
                <input type="number" x-model.number="tag.defaultCapacity" @change="updateTag(tag)" class="input input-bordered input-xs w-16" min="1">
              </div>
            </div>
            <button @click="deleteTag(tag)" :disabled="tag.id === 'untagged'" class="btn btn-ghost btn-sm text-error disabled:opacity-30"><ion-icon name="trash-outline"></ion-icon></button>
          </div>
        </template>
      </div>
      <div class="divider"></div>
      <h4 class="font-medium mb-3">Add New Tag</h4>
      <div class="flex items-center gap-2 flex-wrap">
        <input type="text" x-model="newTagIcon" class="input input-bordered w-12 text-center" placeholder="ðŸ“Œ">
        <input type="text" x-model="newTagName" class="input input-bordered flex-1 min-w-32" placeholder="Tag name">
        <input type="color" x-model="newTagColor" class="w-10 h-10 rounded cursor-pointer">
        <input type="number" x-model.number="newTagCapacity" class="input input-bordered w-16" placeholder="Cap" min="1">
        <button @click="addTag()" :disabled="!newTagName.trim()" class="btn btn-primary">Add</button>
      </div>
    </div>
    <form method="dialog" class="modal-backdrop" @click="showTagsModal = false"><button>close</button></form>
  </dialog>
  
  <!-- Routines Management Modal -->
  <dialog class="modal" :class="{'modal-open': showRoutinesModal}">
    <div class="modal-box max-w-2xl max-h-[90vh]">
      <form method="dialog">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" @click="showRoutinesModal = false">âœ•</button>
      </form>
      <h3 class="text-lg font-bold mb-2">Manage Routines</h3>
      <p class="text-sm opacity-70 mb-4">Routines auto-filter tasks based on time. Higher priority wins when multiple match.</p>
      <div class="space-y-3 mb-6">
        <template x-for="routine in routines" :key="routine.id">
          <div class="p-4 bg-base-200 rounded-lg">
            <div class="flex items-start justify-between gap-4">
              <div class="flex-1">
                <div class="flex items-center gap-2 mb-2">
                  <input type="text" x-model="routine.icon" @change="updateRoutine(routine)" class="input input-ghost w-10 text-center p-0">
                  <input type="text" x-model="routine.name" @change="updateRoutine(routine)" class="input input-ghost font-medium p-0 h-auto" :style="{ color: routine.color }">
                  <span class="text-xs opacity-60">Priority:</span>
                  <input type="number" x-model.number="routine.priority" @change="updateRoutine(routine)" class="input input-bordered input-xs w-14" min="1" max="10">
                </div>
                <div class="grid grid-cols-2 gap-2 text-sm">
                  <div class="form-control">
                    <label class="label py-0"><span class="label-text-alt">Task Filter</span></label>
                    <input type="text" x-model="routine.taskFilterExpression" @change="updateRoutine(routine)" class="input input-bordered input-sm" placeholder="hasTag('work')">
                  </div>
                  <div class="form-control">
                    <label class="label py-0"><span class="label-text-alt">Activation</span></label>
                    <input type="text" x-model="routine.activationExpression" @change="updateRoutine(routine)" class="input input-bordered input-sm" placeholder="isWeekday">
                  </div>
                </div>
              </div>
              <div class="flex items-center gap-1">
                <input type="color" x-model="routine.color" @change="updateRoutine(routine)" class="w-8 h-8 rounded cursor-pointer">
                <button @click="deleteRoutine(routine)" class="btn btn-ghost btn-sm text-error"><ion-icon name="trash-outline"></ion-icon></button>
              </div>
            </div>
          </div>
        </template>
        <template x-if="routines.length === 0">
          <p class="text-center opacity-50 py-4">No routines yet</p>
        </template>
      </div>
      <div class="divider"></div>
      <h4 class="font-medium mb-3">Add New Routine</h4>
      <div class="grid grid-cols-2 gap-3 mb-3">
        <div class="flex items-center gap-2">
          <input type="text" x-model="newRoutineIcon" class="input input-bordered w-12 text-center" placeholder="ðŸ ">
          <input type="text" x-model="newRoutineName" class="input input-bordered flex-1" placeholder="Routine name">
        </div>
        <div class="flex items-center gap-2">
          <input type="color" x-model="newRoutineColor" class="w-10 h-10 rounded cursor-pointer">
          <input type="number" x-model.number="newRoutinePriority" class="input input-bordered w-16" placeholder="Pri" min="1" max="10">
        </div>
        <input type="text" x-model="newRoutineFilter" class="input input-bordered" placeholder="Task filter (e.g., hasTag('work'))">
        <input type="text" x-model="newRoutineActivation" class="input input-bordered" placeholder="Activation (e.g., isWeekday)">
      </div>
      <div class="flex justify-end mb-4">
        <button @click="addRoutine()" :disabled="!newRoutineName.trim()" class="btn btn-primary">Add Routine</button>
      </div>
      <div class="alert alert-info">
        <div>
          <p class="font-medium mb-1">Expression Examples:</p>
          <div class="grid grid-cols-2 gap-2 text-xs font-mono">
            <div>hasTag("Work")</div>
            <div>isWeekday and hour >= 9</div>
            <div>age > 7</div>
            <div>dayOfWeek == "mon"</div>
          </div>
        </div>
      </div>
    </div>
    <form method="dialog" class="modal-backdrop" @click="showRoutinesModal = false"><button>close</button></form>
  </dialog>
  
  <!-- Settings Modal -->
  <dialog class="modal" :class="{'modal-open': showSettingsModal}">
    <div class="modal-box max-w-md">
      <form method="dialog">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" @click="showSettingsModal = false">âœ•</button>
      </form>
      <h3 class="text-lg font-bold mb-4">Settings</h3>
      <div class="space-y-4">
        <div class="form-control">
          <label class="label"><span class="label-text">Default Session Duration</span></label>
          <select x-model.number="settings.defaultSessionDuration" class="select select-bordered w-full">
            <option value="15">15 minutes</option>
            <option value="25">25 minutes (Pomodoro)</option>
            <option value="45">45 minutes</option>
            <option value="60">60 minutes</option>
          </select>
        </div>
        <div class="divider"></div>
        <div>
          <h4 class="font-medium text-error mb-2">Danger Zone</h4>
          <button @click="resetAllData()" class="btn btn-error btn-outline w-full gap-2"><ion-icon name="trash-outline"></ion-icon> Reset All Data</button>
        </div>
      </div>
    </div>
    <form method="dialog" class="modal-backdrop" @click="showSettingsModal = false"><button>close</button></form>
  </dialog>
  
  <script>
    function checkMate() {
      return {
        // === CONSTANTS ===
        FIBONACCI_POINTS: [1, 2, 3, 5, 8, 13, 21],
        DAYS: ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'],
        
        // === STATE (persisted) ===
        tasks: Alpine.$persist([]).as('checkmate_tasks'),
        tags: Alpine.$persist([]).as('checkmate_tags'),
        sprints: Alpine.$persist([]).as('checkmate_sprints'),
        routines: Alpine.$persist([]).as('checkmate_routines'),
        settings: Alpine.$persist({ defaultSessionDuration: 25, theme: 'light' }).as('checkmate_settings'),
        
        // === UI STATE ===
        currentView: 'sprint',
        selectedSprintIndex: 0,
        selectedTagFilters: [],
        manualRoutineId: '',
        today: new Date(),
        
        // === MODAL STATE ===
        showCreateTaskModal: false,
        showTaskDetailModal: false,
        showSkipForDayModal: false,
        showCompleteSessionModal: false,
        showSprintHealthModal: false,
        showCapacityEditModal: false,
        showTagsModal: false,
        showRoutinesModal: false,
        showSettingsModal: false,
        
        // === FORM STATE ===
        newTask: { title: '', description: '', tagPoints: {} },
        selectedTask: null,
        newCommentContent: '',
        skipJustification: '',
        taskToSkip: null,
        sessionFocusLevel: 'neutral',
        sessionNote: '',
        markTaskComplete: false,
        capacityEditSprint: null,
        capacityEditTag: null,
        capacityEditValue: 0,
        newTagName: '',
        newTagIcon: 'ðŸ“Œ',
        newTagColor: '#6366f1',
        newTagCapacity: 20,
        newRoutineName: '',
        newRoutineIcon: 'ðŸ ',
        newRoutineColor: '#6366f1',
        newRoutinePriority: 5,
        newRoutineFilter: '',
        newRoutineActivation: '',
        
        // === SESSION TRACKING ===
        activeSession: null,
        sessionElapsed: 0,
        sessionInterval: null,
        
        // === COMPUTED PROPERTIES ===
        get selectedSprint() {
          return this.sprints[this.selectedSprintIndex];
        },
        
        get backlogTasks() {
          return this.tasks.filter(t => t.location.type === 'backlog' && t.status === 'active' && !t.recurrence);
        },
        
        get filteredBacklogTasks() {
          let tasks = this.backlogTasks;
          if (this.selectedTagFilters.length > 0) {
            tasks = tasks.filter(t => Object.keys(t.tagPoints).some(tagId => this.selectedTagFilters.includes(tagId)));
          }
          if (this.activeRoutine) {
            tasks = tasks.filter(t => this.evaluateTaskFilter(t, this.activeRoutine.taskFilterExpression));
          }
          return tasks;
        },
        
        get recurringTemplates() {
          return this.tasks.filter(t => t.recurrence && t.status === 'active');
        },
        
        get completedTasks() {
          return this.tasks.filter(t => t.status === 'completed' || t.status === 'canceled');
        },
        
        get activeRoutine() {
          if (this.manualRoutineId) {
            return this.routines.find(r => r.id === this.manualRoutineId);
          }
          const matching = this.routines.filter(r => this.evaluateActivationExpression(r.activationExpression));
          if (matching.length === 0) return null;
          matching.sort((a, b) => {
            if (b.priority !== a.priority) return b.priority - a.priority;
            return a.name.localeCompare(b.name);
          });
          return matching[0];
        },
        
        // === LIFECYCLE ===
        init() {
          this.initializeDefaults();
          this.initializeSprints();
          setInterval(() => {
            this.today = new Date();
            this.checkSkipReturns();
          }, 60000);
          this.checkSkipReturns();
          console.log('Check Mate initialized');
        },
        
        initializeDefaults() {
          if (this.tags.length === 0) {
            this.tags = [
              { id: 'untagged', name: 'Untagged', icon: 'ðŸ“¦', color: '#6b7280', defaultCapacity: 10, description: '' },
              { id: this.generateId(), name: 'Work', icon: 'ðŸ’¼', color: '#3b82f6', defaultCapacity: 25, description: 'Work tasks' },
              { id: this.generateId(), name: 'Personal', icon: 'ðŸ ', color: '#22c55e', defaultCapacity: 15, description: 'Personal tasks' },
              { id: this.generateId(), name: 'Health', icon: 'â¤ï¸', color: '#ef4444', defaultCapacity: 10, description: 'Health & fitness' },
              { id: this.generateId(), name: 'Learning', icon: 'ðŸ“š', color: '#8b5cf6', defaultCapacity: 10, description: 'Learning & growth' },
            ];
          }
          
          if (this.routines.length === 0) {
            this.routines = [
              { id: this.generateId(), name: 'Work Hours', icon: 'ðŸ’¼', color: '#3b82f6', priority: 8, taskFilterExpression: 'hasTag("Work")', activationExpression: 'isWeekday and hour >= 9 and hour < 18' },
              { id: this.generateId(), name: 'Evening', icon: 'ðŸŒ™', color: '#8b5cf6', priority: 5, taskFilterExpression: 'hasAnyTag("Personal", "Health")', activationExpression: 'hour >= 18 or hour < 9' },
              { id: this.generateId(), name: 'Weekend', icon: 'â˜€ï¸', color: '#f59e0b', priority: 7, taskFilterExpression: 'hasAnyTag("Personal", "Health", "Learning")', activationExpression: 'isWeekend' }
            ];
          }
        },
        
        initializeSprints() {
          const now = new Date();
          const currentSunday = this.getStartOfWeek(now);
          
          const requiredStarts = [currentSunday, this.addDays(currentSunday, 7), this.addDays(currentSunday, 14)];
          
          requiredStarts.forEach((startDate) => {
            const exists = this.sprints.find(s => new Date(s.startDate).toDateString() === startDate.toDateString());
            if (!exists) {
              this.sprints.push({
                id: this.generateId(),
                startDate: startDate.toISOString(),
                endDate: this.addDays(startDate, 6).toISOString(),
                capacityOverrides: {},
                taskIds: []
              });
            }
          });
          
          this.sprints.sort((a, b) => new Date(a.startDate) - new Date(b.startDate));
          
          const currentIndex = this.sprints.findIndex(s => new Date(s.startDate).toDateString() === currentSunday.toDateString());
          
          if (currentIndex > 0) {
            this.sprints.slice(0, currentIndex).forEach(pastSprint => {
              this.tasks.filter(t => t.location.type === 'sprint' && t.location.sprintId === pastSprint.id)
                .forEach(task => {
                  task.location = { type: 'backlog' };
                  task.sprintHistory = task.sprintHistory || [];
                  task.sprintHistory.push(pastSprint.id);
                });
            });
            this.sprints = this.sprints.slice(currentIndex, currentIndex + 3);
          }
          
          if (this.sprints.length > 3) {
            this.sprints = this.sprints.slice(0, 3);
          }
        },
        
        // === HELPER FUNCTIONS ===
        generateId() {
          return 'id_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
        },
        
        getTagById(tagId) {
          return this.tags.find(t => t.id === tagId);
        },
        
        getTaskById(taskId) {
          return this.tasks.find(t => t.id === taskId);
        },
        
        getTaskPrimaryTag(task) {
          const firstTagId = Object.keys(task.tagPoints)[0];
          return this.getTagById(firstTagId);
        },
        
        getTaskAge(task) {
          const created = new Date(task.createdAt);
          const diff = this.today - created;
          return Math.floor(diff / (1000 * 60 * 60 * 24));
        },
        
        formatDate(date) {
          if (!date) return '';
          const d = new Date(date);
          return d.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
        },
        
        formatSessionTime(seconds) {
          const mins = Math.floor(seconds / 60);
          const secs = seconds % 60;
          return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        },
        
        getStartOfWeek(date) {
          const d = new Date(date);
          const day = d.getDay();
          d.setDate(d.getDate() - day);
          d.setHours(0, 0, 0, 0);
          return d;
        },
        
        addDays(date, days) {
          const d = new Date(date);
          d.setDate(d.getDate() + days);
          return d;
        },
        
        checkSkipReturns() {
          const now = new Date();
          this.tasks.forEach(task => {
            if (task.skipState?.type === 'for_day' && new Date(task.skipState.returnAt) <= now) {
              task.skipState.returned = true;
            }
          });
        },
        
        // === EXPRESSION EVALUATOR ===
        evaluateTaskFilter(task, expression) {
          if (!expression || expression.trim() === '' || expression === 'true') return true;
          if (expression === 'false') return false;
          
          try {
            const tagIds = Object.keys(task.tagPoints);
            const tagNames = tagIds.map(id => this.getTagById(id)?.name?.toLowerCase()).filter(Boolean);
            
            const context = {
              title: task.title,
              description: task.description || '',
              status: task.status,
              age: this.getTaskAge(task),
              sprintCount: task.sprintHistory?.length || 0,
              inBacklog: task.location.type === 'backlog',
              inSprint: task.location.type === 'sprint',
              points: Object.values(task.tagPoints).reduce((a, b) => a + b, 0)
            };
            
            const funcs = {
              hasTag: (name) => tagNames.includes(name.toLowerCase()),
              hasAnyTag: (...names) => names.some(n => tagNames.includes(n.toLowerCase())),
              hasAllTags: (...names) => names.every(n => tagNames.includes(n.toLowerCase()))
            };
            
            return this.safeEval(expression, context, funcs);
          } catch (e) {
            console.error('Task filter eval error:', e, expression);
            return true;
          }
        },
        
        evaluateActivationExpression(expression) {
          if (!expression || expression.trim() === '' || expression === 'false') return false;
          if (expression === 'true') return true;
          
          try {
            const now = this.today;
            const context = {
              hour: now.getHours(),
              minute: now.getMinutes(),
              dayOfWeek: this.DAYS[now.getDay()],
              date: now.getDate(),
              month: now.getMonth() + 1,
              year: now.getFullYear(),
              isWeekday: now.getDay() > 0 && now.getDay() < 6,
              isWeekend: now.getDay() === 0 || now.getDay() === 6,
              time: now.getHours() * 60 + now.getMinutes()
            };
            
            return this.safeEval(expression, context, {});
          } catch (e) {
            console.error('Activation eval error:', e, expression);
            return false;
          }
        },
        
        // Safe expression evaluation using Filtrex (no eval!)
        safeEval(expression, context, funcs) {
          try {
            // Normalize expression: convert 'and'/'or' to filtrex operators
            let expr = expression
              .replace(/\band\b/gi, ' and ')
              .replace(/\bor\b/gi, ' or ')
              .replace(/\bnot\b/gi, ' not ');

            // Compile expression with custom functions
            const filter = filtrex.compileExpression(expr, { extraFunctions: funcs });
            return Boolean(filter(context));
          } catch (e) {
            console.error('Filtrex error:', e, expression);
            return true; // Default to true on error
          }
        },
        
        // === TASK OPERATIONS ===
        createTask() {
          const tagPoints = {};
          Object.entries(this.newTask.tagPoints).forEach(([tagId, points]) => {
            if (points) tagPoints[tagId] = parseInt(points);
          });
          
          if (Object.keys(tagPoints).length === 0) {
            alert('Please assign points to at least one tag');
            return;
          }
          
          // Check if title contains recurrence pattern
          const parsed = this.parseRecurrence(this.newTask.title);

          const task = {
            id: this.generateId(),
            title: parsed.valid ? parsed.cleanTitle : this.newTask.title,
            description: this.newTask.description || '',
            status: 'active',
            tagPoints: tagPoints,
            location: { type: 'backlog' },
            createdAt: new Date().toISOString(),
            comments: [],
            sessions: [],
            skipState: null,
            recurrence: parsed.valid ? parsed.rruleString : null,
            parentId: null,
            externalSource: null,
            sprintHistory: []
          };

          this.tasks.push(task);
          this.newTask = { title: '', description: '', tagPoints: {} };
          this.showCreateTaskModal = false;
        },
        
        updateTask(task) {
          const index = this.tasks.findIndex(t => t.id === task.id);
          if (index !== -1) this.tasks[index] = { ...task };
        },
        
        completeTask(task) {
          task.status = 'completed';
          task.completedAt = new Date().toISOString();
          this.updateTask(task);
        },
        
        cancelTask(task) {
          if (confirm(`Cancel task "${task.title}"?`)) {
            task.status = 'canceled';
            task.canceledAt = new Date().toISOString();
            this.updateTask(task);
          }
        },
        
        moveTaskToSprint(task, sprint) {
          task.location = { type: 'sprint', sprintId: sprint.id };
          task.skipState = null;
          this.updateTask(task);
        },
        
        moveTaskToBacklog(task) {
          if (task.location.type === 'sprint') {
            task.sprintHistory = task.sprintHistory || [];
            task.sprintHistory.push(task.location.sprintId);
          }
          task.location = { type: 'backlog' };
          task.skipState = null;
          this.updateTask(task);
        },
        
        skipTaskForNow(task) {
          task.skipState = { type: 'for_now', skippedAt: new Date().toISOString() };
          this.updateTask(task);
        },
        
        openSkipForDayModal(task) {
          this.taskToSkip = task;
          this.skipJustification = '';
          this.showSkipForDayModal = true;
        },
        
        confirmSkipForDay() {
          if (!this.skipJustification.trim()) return;
          
          const comment = {
            id: this.generateId(),
            content: this.skipJustification,
            createdAt: new Date().toISOString(),
            updatedAt: null,
            skipJustification: true
          };
          
          this.taskToSkip.comments = this.taskToSkip.comments || [];
          this.taskToSkip.comments.push(comment);
          
          const tomorrow = new Date();
          tomorrow.setDate(tomorrow.getDate() + 1);
          tomorrow.setHours(0, 0, 0, 0);
          
          this.taskToSkip.skipState = {
            type: 'for_day',
            skippedAt: new Date().toISOString(),
            returnAt: tomorrow.toISOString(),
            justificationCommentId: comment.id
          };
          
          this.updateTask(this.taskToSkip);
          this.showSkipForDayModal = false;
          this.taskToSkip = null;
        },
        
        clearSkipState(task) {
          task.skipState = null;
          this.updateTask(task);
        },
        
        openTaskDetail(task) {
          this.selectedTask = JSON.parse(JSON.stringify(task));
          this.newCommentContent = '';
          this.showTaskDetailModal = true;
        },
        
        saveTaskDetail() {
          if (!this.selectedTask) return;
          const index = this.tasks.findIndex(t => t.id === this.selectedTask.id);
          if (index !== -1) this.tasks[index] = this.selectedTask;
        },
        
        addComment(task) {
          if (!this.newCommentContent.trim()) return;
          
          const actualTask = this.tasks.find(t => t.id === task.id);
          if (!actualTask) return;
          
          actualTask.comments = actualTask.comments || [];
          actualTask.comments.push({
            id: this.generateId(),
            content: this.newCommentContent,
            createdAt: new Date().toISOString(),
            updatedAt: null,
            skipJustification: false
          });
          
          this.selectedTask = JSON.parse(JSON.stringify(actualTask));
          this.newCommentContent = '';
        },
        
        deleteComment(task, comment) {
          const actualTask = this.tasks.find(t => t.id === task.id);
          if (!actualTask) return;
          
          actualTask.comments = actualTask.comments.filter(c => c.id !== comment.id);
          this.selectedTask = JSON.parse(JSON.stringify(actualTask));
        },
        
        spawnRecurringInstance(template) {
          const instance = {
            id: this.generateId(),
            title: template.title,
            description: template.description,
            status: 'active',
            tagPoints: { ...template.tagPoints },
            location: { type: 'backlog' },
            createdAt: new Date().toISOString(),
            comments: [],
            sessions: [],
            skipState: null,
            recurrence: null,
            parentId: template.id,
            externalSource: null,
            sprintHistory: []
          };
          
          this.tasks.push(instance);
          return instance;
        },
        
        getNextOccurrence(template) {
          if (!template.recurrence) return null;
          try {
            const rule = rrule.RRule.fromString('DTSTART:' + new Date().toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z\nRRULE:' + template.recurrence);
            return rule.after(new Date());
          } catch (e) {
            console.error('RRule error:', e);
            return new Date();
          }
        },
        
        describeRRule(rruleStr) {
          if (!rruleStr) return '';
          try {
            const rule = rrule.RRule.fromString('RRULE:' + rruleStr);
            return rule.toText();
          } catch (e) {
            return rruleStr;
          }
        },

        parseRecurrence(text) {
          if (!text || !text.trim()) {
            return { valid: false, rruleString: null, description: '', cleanTitle: text };
          }

          // Look for "every ..." pattern in the text
          const everyMatch = text.match(/\bevery\s+.+$/i);
          if (!everyMatch) {
            return { valid: false, rruleString: null, description: '', cleanTitle: text };
          }

          try {
            // Pass only the "every ..." part to fromText
            const recurrenceText = everyMatch[0];
            const rule = rrule.RRule.fromText(recurrenceText);
            const recurrenceDesc = rule.toText();

            // Remove the recurrence part from title
            const cleanTitle = text.replace(/\s*\bevery\s+.+$/i, '').trim();

            return {
              valid: true,
              rruleString: rule.toString().replace('RRULE:', ''),
              description: recurrenceDesc,
              cleanTitle: cleanTitle || text.trim()
            };
          } catch (e) {
            return { valid: false, rruleString: null, description: '', cleanTitle: text };
          }
        },
        
        // === SPRINT OPERATIONS ===
        getSprintTasks(sprint) {
          if (!sprint) return [];
          
          let tasks = this.tasks.filter(t => t.location.type === 'sprint' && t.location.sprintId === sprint.id && t.status === 'active');
          
          if (this.selectedTagFilters.length > 0) {
            tasks = tasks.filter(t => Object.keys(t.tagPoints).some(tagId => this.selectedTagFilters.includes(tagId)));
          }
          
          if (this.activeRoutine) {
            tasks = tasks.filter(t => this.evaluateTaskFilter(t, this.activeRoutine.taskFilterExpression));
          }
          
          return tasks.sort((a, b) => {
            // Returned tasks bubble to top
            if (a.skipState?.type === 'for_day' && a.skipState?.returned) return -1;
            if (b.skipState?.type === 'for_day' && b.skipState?.returned) return 1;
            // Skipped-for-day tasks go to bottom
            if (a.skipState?.type === 'for_day' && !a.skipState?.returned) return 1;
            if (b.skipState?.type === 'for_day' && !b.skipState?.returned) return -1;
            // Skipped-for-now go after normal tasks
            if (a.skipState?.type === 'for_now' && !b.skipState) return 1;
            if (b.skipState?.type === 'for_now' && !a.skipState) return -1;
            // Otherwise sort by order
            return (a.order || 0) - (b.order || 0);
          });
        },

        handleTaskReorder(itemId, newPosition) {
          const sprintTasks = this.getSprintTasks(this.selectedSprint);
          const taskIds = sprintTasks.map(t => t.id);

          // Remove from old position and insert at new
          const oldIndex = taskIds.indexOf(itemId);
          if (oldIndex !== -1) {
            taskIds.splice(oldIndex, 1);
          }
          taskIds.splice(newPosition, 0, itemId);

          // Update order values
          taskIds.forEach((id, index) => {
            const task = this.tasks.find(t => t.id === id);
            if (task) task.order = index;
          });
        },

        getSprintLabel(index) {
          if (index === 0) return 'Current Sprint';
          if (index === 1) return 'Next Sprint';
          if (index === 2) return 'Sprint +2';
          return `Sprint ${index}`;
        },

        getSprintIcon(index) {
          if (index === 0) return 'calendar-outline';
          if (index === 1) return 'arrow-forward-outline';
          if (index === 2) return 'play-skip-forward-outline';
          return 'calendar-outline';
        },
        
        getDaysRemaining(sprint) {
          const end = new Date(sprint.endDate);
          const diff = Math.ceil((end - this.today) / (1000 * 60 * 60 * 24));
          return Math.max(0, diff + 1);
        },
        
        getSprintPointsForTag(sprint, tagId) {
          return this.tasks
            .filter(t => t.location.type === 'sprint' && t.location.sprintId === sprint.id && t.status === 'active')
            .reduce((sum, task) => sum + (task.tagPoints[tagId] || 0), 0);
        },
        
        getCapacityForTag(sprint, tagId) {
          if (sprint.capacityOverrides && sprint.capacityOverrides[tagId]) {
            return sprint.capacityOverrides[tagId];
          }
          const tag = this.getTagById(tagId);
          return tag?.defaultCapacity || 10;
        },
        
        getSprintHealth(sprint) {
          if (!sprint) return { overall: 'on_track' };
          let worstHealth = 'on_track';
          
          this.tags.forEach(tag => {
            const health = this.getTagHealth(sprint, tag.id);
            if (health === 'off_track') worstHealth = 'off_track';
            else if (health === 'at_risk' && worstHealth !== 'off_track') worstHealth = 'at_risk';
          });
          
          return { overall: worstHealth };
        },
        
        getTagHealth(sprint, tagId) {
          const assigned = this.getSprintPointsForTag(sprint, tagId);
          const capacity = this.getCapacityForTag(sprint, tagId);
          const daysRemaining = Math.max(1, this.getDaysRemaining(sprint));
          
          if (assigned === 0) return 'on_track';
          
          const burnRateNeeded = assigned / daysRemaining;
          const sustainableRate = capacity / 7;
          
          if (burnRateNeeded > sustainableRate * 1.5) return 'off_track';
          if (burnRateNeeded > sustainableRate * 1.2) return 'at_risk';
          return 'on_track';
        },
        
        getBurnRateNeeded(sprint, tagId) {
          const assigned = this.getSprintPointsForTag(sprint, tagId);
          const daysRemaining = Math.max(1, this.getDaysRemaining(sprint));
          return assigned / daysRemaining;
        },
        
        editSprintCapacity(sprint, tag) {
          this.capacityEditSprint = sprint;
          this.capacityEditTag = tag;
          this.capacityEditValue = this.getCapacityForTag(sprint, tag.id);
          this.showCapacityEditModal = true;
        },
        
        saveCapacityOverride() {
          if (!this.capacityEditSprint.capacityOverrides) {
            this.capacityEditSprint.capacityOverrides = {};
          }
          this.capacityEditSprint.capacityOverrides[this.capacityEditTag.id] = this.capacityEditValue;
          this.showCapacityEditModal = false;
        },
        
        // === SESSION OPERATIONS ===
        startSession(task) {
          if (this.activeSession) return;
          
          const session = {
            id: this.generateId(),
            taskId: task.id,
            status: 'in_progress',
            startedAt: new Date().toISOString(),
            endedAt: null,
            focusLevel: null,
            comments: []
          };
          
          const actualTask = this.tasks.find(t => t.id === task.id);
          actualTask.sessions = actualTask.sessions || [];
          actualTask.sessions.push(session);
          
          this.activeSession = session;
          this.sessionElapsed = 0;
          
          this.sessionInterval = setInterval(() => {
            this.sessionElapsed++;
          }, 1000);
          
          this.showTaskDetailModal = false;
        },
        
        openCompleteSessionModal() {
          this.sessionFocusLevel = 'neutral';
          this.sessionNote = '';
          this.markTaskComplete = false;
          this.showCompleteSessionModal = true;
        },
        
        confirmCompleteSession() {
          if (!this.activeSession) return;
          
          const task = this.getTaskById(this.activeSession.taskId);
          const session = task.sessions.find(s => s.id === this.activeSession.id);
          
          session.status = 'completed';
          session.endedAt = new Date().toISOString();
          session.focusLevel = this.sessionFocusLevel;
          
          if (this.sessionNote.trim()) {
            session.comments = [{ id: this.generateId(), content: this.sessionNote, createdAt: new Date().toISOString() }];
          }
          
          if (this.markTaskComplete) {
            this.completeTask(task);
          }
          
          this.cleanupSession();
          this.showCompleteSessionModal = false;
        },
        
        abandonSession() {
          if (!this.activeSession) return;
          
          const task = this.getTaskById(this.activeSession.taskId);
          const session = task.sessions.find(s => s.id === this.activeSession.id);
          
          session.status = 'abandoned';
          session.endedAt = new Date().toISOString();
          
          this.cleanupSession();
        },
        
        cleanupSession() {
          clearInterval(this.sessionInterval);
          this.activeSession = null;
          this.sessionElapsed = 0;
          this.sessionFocusLevel = 'neutral';
          this.sessionNote = '';
          this.markTaskComplete = false;
        },
        
        // === TAG OPERATIONS ===
        addTag() {
          if (!this.newTagName.trim()) return;
          
          this.tags.push({
            id: this.generateId(),
            name: this.newTagName,
            icon: this.newTagIcon || 'ðŸ“Œ',
            color: this.newTagColor || '#6366f1',
            defaultCapacity: this.newTagCapacity || 20,
            description: ''
          });
          
          this.newTagName = '';
          this.newTagIcon = 'ðŸ“Œ';
          this.newTagColor = '#6366f1';
          this.newTagCapacity = 20;
        },
        
        updateTag(tag) {
          const index = this.tags.findIndex(t => t.id === tag.id);
          if (index !== -1) this.tags[index] = { ...tag };
        },
        
        deleteTag(tag) {
          if (tag.id === 'untagged') {
            alert('Cannot delete the Untagged tag');
            return;
          }
          
          const tasksWithTag = this.tasks.filter(t => t.tagPoints[tag.id]);
          if (tasksWithTag.length > 0) {
            alert(`Cannot delete tag "${tag.name}" - ${tasksWithTag.length} task(s) use it`);
            return;
          }
          
          this.tags = this.tags.filter(t => t.id !== tag.id);
        },
        
        toggleTagFilter(tagId) {
          if (tagId === null) {
            this.selectedTagFilters = [];
          } else {
            const index = this.selectedTagFilters.indexOf(tagId);
            if (index === -1) {
              this.selectedTagFilters.push(tagId);
            } else {
              this.selectedTagFilters.splice(index, 1);
            }
          }
        },
        
        // === ROUTINE OPERATIONS ===
        addRoutine() {
          if (!this.newRoutineName.trim()) return;
          
          this.routines.push({
            id: this.generateId(),
            name: this.newRoutineName,
            icon: this.newRoutineIcon || 'ðŸ”„',
            color: this.newRoutineColor || '#6366f1',
            priority: this.newRoutinePriority || 5,
            taskFilterExpression: this.newRoutineFilter || 'true',
            activationExpression: this.newRoutineActivation || 'false'
          });
          
          this.newRoutineName = '';
          this.newRoutineIcon = 'ðŸ ';
          this.newRoutineColor = '#6366f1';
          this.newRoutinePriority = 5;
          this.newRoutineFilter = '';
          this.newRoutineActivation = '';
        },
        
        updateRoutine(routine) {
          const index = this.routines.findIndex(r => r.id === routine.id);
          if (index !== -1) this.routines[index] = { ...routine };
        },
        
        deleteRoutine(routine) {
          this.routines = this.routines.filter(r => r.id !== routine.id);
        },
        
        clearRoutineOverride() {
          this.manualRoutineId = '';
        },
        
        // === RESET ===
        resetAllData() {
          if (!confirm('This will delete ALL data. Are you sure?')) return;
          localStorage.removeItem('checkmate_tasks');
          localStorage.removeItem('checkmate_tags');
          localStorage.removeItem('checkmate_sprints');
          localStorage.removeItem('checkmate_routines');
          localStorage.removeItem('checkmate_settings');
          location.reload();
        }
      }
    }
  </script>
</body>
</html>
