
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Check Mate - ADHD Task Manager</title>

  <!-- Theme initialization (before CSS to prevent flash) -->
  <script>
    (function() {
      const saved = localStorage.getItem('checkmate_theme');
      if (saved) {
        document.documentElement.setAttribute('data-theme', saved);
      } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.documentElement.setAttribute('data-theme', 'dark');
      }
    })();
  </script>

  <!-- daisyUI + Tailwind CSS v4 -->
  <link href="https://cdn.jsdelivr.net/npm/daisyui@5" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/daisyui@5/themes.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>

  <!-- Custom theme colors -->
  <style type="text/tailwindcss">
    @theme {
      --color-on-track: #22c55e;
      --color-at-risk: #eab308;
      --color-off-track: #ef4444;
    }
  </style>

  <!-- RRule for recurrence -->
  <script src="https://cdn.jsdelivr.net/npm/rrule@2.8.1/dist/es5/rrule.min.js"></script>

  <!-- Filtrex for safe expression evaluation -->
  <script src="https://cdn.jsdelivr.net/npm/filtrex@3.1.0/dist/browser/filtrex.min.js"></script>

  <!-- Alpine Plugins -->
  <script defer src="https://cdn.jsdelivr.net/npm/@alpinejs/persist@3/dist/cdn.min.js"></script>

  <!-- Alpine.js -->
  <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js"></script>

  <!-- SortableJS for drag-drop (used directly, not via Alpine) -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>

  <!-- Ionicons -->
  <script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"></script>
  <script nomodule src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js"></script>

  <style>
    /* Ionicons sizing */
    ion-icon { font-size: 1.25rem; }
    [x-cloak] { display: none !important; }
    .task-card { transition: all 0.2s ease; }
    .task-card:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
    .health-pulse { animation: pulse 2s infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    .line-clamp-2 { display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    /* Drag and drop styles */
    .sortable-ghost { opacity: 0.4; }
    .sortable-drag { box-shadow: 0 10px 20px rgba(0,0,0,0.15); }
    .sortable-chosen { cursor: grabbing; }
    /* Kanban layout */
    .kanban-container { display: flex; gap: 1rem; overflow-x: auto; min-height: 400px; }
    .kanban-column { flex: 1; min-width: 250px; max-width: 400px; display: flex; flex-direction: column; }
    .kanban-column-content { flex: 1; min-height: 100px; }
    .kanban-task { transition: transform 0.15s ease, box-shadow 0.15s ease; }
    .kanban-task:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
    /* Mobile: stacked collapsible */
    @media (max-width: 768px) {
      .kanban-container { flex-direction: column; overflow-x: visible; min-height: auto; }
      .kanban-column { max-width: none; min-width: auto; }
      .kanban-column-content { min-height: 50px; }
    }
  </style>
</head>
<body class="bg-base-200 min-h-screen pb-20" x-cloak x-data="checkMate()" x-init="init()">

  <!-- Main Drawer Layout -->
  <div class="drawer drawer-end">
    <input id="main-drawer" type="checkbox" class="drawer-toggle" />

    <!-- Main Content -->
    <div class="drawer-content flex flex-col">

      <!-- Minimal Navbar -->
      <div class="navbar bg-base-100 shadow-sm sticky top-0 z-10">
        <div class="navbar-start gap-2">
          <ion-icon name="checkbox-outline" class="text-2xl text-primary"></ion-icon>
          <span class="font-bold text-lg">Check Mate</span>
        </div>
        <div class="navbar-center">
          <template x-if="activeRoutine">
            <div class="badge gap-1" :style="{ backgroundColor: activeRoutine.color + '20', color: activeRoutine.color }">
              <span x-text="activeRoutine.icon"></span>
              <span x-text="activeRoutine.name" class="hidden sm:inline"></span>
            </div>
          </template>
        </div>
        <div class="navbar-end gap-1">
          <!-- Theme Toggle (using daisyUI theme-controller) -->
          <label class="swap swap-rotate btn btn-ghost btn-circle btn-sm">
            <input type="checkbox" value="dark" class="theme-controller"
                   @change="localStorage.setItem('checkmate_theme', $event.target.checked ? 'dark' : 'light')"
                   :checked="document.documentElement.getAttribute('data-theme') === 'dark'" />
            <ion-icon name="sunny-outline" class="swap-off"></ion-icon>
            <ion-icon name="moon-outline" class="swap-on"></ion-icon>
          </label>
          <!-- Drawer Toggle -->
          <label for="main-drawer" class="btn btn-ghost btn-circle btn-sm">
            <ion-icon name="menu-outline"></ion-icon>
          </label>
        </div>
      </div>

      <!-- Page Content -->
      <div class="flex-1 p-4 mx-auto w-full" :class="currentView === 'tasks' ? 'max-w-6xl' : 'max-w-2xl'">

        <!-- Active Session Banner (shown in any view) -->
        <template x-if="activeSession">
          <div class="alert alert-info shadow-lg mb-4">
            <ion-icon name="radio-button-on-outline" class="text-2xl animate-pulse"></ion-icon>
            <div class="flex-1">
              <p class="text-sm opacity-80">Focusing on</p>
              <p class="font-bold" x-text="getTaskById(activeSession.taskId)?.title"></p>
            </div>
            <div class="text-center">
              <p class="text-2xl font-mono font-bold" x-text="formatSessionTime(sessionElapsed)"></p>
            </div>
            <div class="flex gap-1">
              <button @click="openCompleteSessionModal()" class="btn btn-success btn-sm btn-circle"><ion-icon name="checkmark-outline"></ion-icon></button>
              <button @click="abandonSession()" class="btn btn-ghost btn-sm btn-circle"><ion-icon name="close-outline"></ion-icon></button>
            </div>
          </div>
        </template>

        <!-- ==================== FOCUS VIEW ==================== -->
        <div x-show="currentView === 'focus'" class="space-y-4">
          <!-- Hero: Focus on ONE task -->
          <template x-if="focusTask">
            <div class="hero bg-base-100 rounded-box shadow-sm py-8">
              <div class="hero-content text-center flex-col">
                <div class="max-w-md">
                  <p class="text-sm opacity-60 mb-2">Focus on this now</p>
                  <h1 class="text-2xl font-bold mb-4" x-text="focusTask.title"></h1>
                  <div class="flex flex-wrap justify-center gap-2 mb-6">
                    <template x-for="(points, tagId) in focusTask.tagPoints" :key="tagId">
                      <span class="badge badge-lg" :style="{ backgroundColor: getTagById(tagId)?.color + '20', color: getTagById(tagId)?.color }">
                        <span x-text="getTagById(tagId)?.icon" class="mr-1"></span>
                        <span x-text="getTagById(tagId)?.name"></span>
                      </span>
                    </template>
                  </div>
                  <div class="flex justify-center gap-2">
                    <button @click="startSession(focusTask)" :disabled="activeSession" class="btn btn-primary btn-lg gap-2">
                      <ion-icon name="play-outline"></ion-icon> Start Focus
                    </button>
                    <button @click="completeTask(focusTask)" class="btn btn-success btn-lg gap-2">
                      <ion-icon name="checkmark-outline"></ion-icon> Done
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </template>

          <!-- No focus task -->
          <template x-if="!focusTask">
            <div class="hero bg-base-100 rounded-box shadow-sm py-12">
              <div class="hero-content text-center">
                <div class="max-w-md">
                  <ion-icon name="checkmark-circle-outline" class="text-6xl text-success mb-4"></ion-icon>
                  <h1 class="text-2xl font-bold mb-2">All Clear!</h1>
                  <p class="opacity-70 mb-4">No tasks in your current sprint. Add some tasks to get started.</p>
                  <button @click="showCreateTaskModal = true" class="btn btn-primary gap-2">
                    <ion-icon name="add-outline"></ion-icon> Add Task
                  </button>
                </div>
              </div>
            </div>
          </template>

          <!-- Quick actions for focus task -->
          <template x-if="focusTask">
            <div class="flex justify-center gap-2">
              <button @click="skipTaskForNow(focusTask)" class="btn btn-ghost btn-sm gap-1">
                <ion-icon name="play-skip-forward-outline"></ion-icon> Skip for now
              </button>
              <button @click="openSkipForDayModal(focusTask)" class="btn btn-ghost btn-sm gap-1">
                <ion-icon name="calendar-outline"></ion-icon> Skip for day
              </button>
              <button @click="openTaskDetail(focusTask)" class="btn btn-ghost btn-sm gap-1">
                <ion-icon name="create-outline"></ion-icon> Details
              </button>
            </div>
          </template>

          <!-- Up next preview -->
          <template x-if="upNextTasks.length > 0">
            <div class="mt-6">
              <p class="text-sm opacity-60 mb-2 text-center">Up next</p>
              <div class="space-y-2">
                <template x-for="task in upNextTasks.slice(0, 3)" :key="task.id">
                  <div class="card bg-base-100 shadow-sm">
                    <div class="card-body p-3 flex-row items-center gap-3">
                      <div class="w-1 h-8 rounded-full" :style="{ backgroundColor: getTaskPrimaryTag(task)?.color }"></div>
                      <span class="flex-1 font-medium truncate" x-text="task.title"></span>
                      <button @click="openTaskDetail(task)" class="btn btn-ghost btn-circle btn-xs">
                        <ion-icon name="chevron-forward-outline"></ion-icon>
                      </button>
                    </div>
                  </div>
                </template>
              </div>
            </div>
          </template>
        </div>

        <!-- ==================== TASKS VIEW (Kanban Board) ==================== -->
        <div x-show="currentView === 'tasks'" x-init="$nextTick(() => initKanban())">

          <!-- Desktop: Kanban columns | Mobile: Collapsible sections -->
          <div class="kanban-container">

            <!-- Backlog Column -->
            <div class="kanban-column">
              <div class="collapse collapse-arrow bg-base-100 shadow-sm md:collapse-open">
                <input type="checkbox" class="md:hidden" />
                <div class="collapse-title font-medium flex items-center gap-2 py-3">
                  <ion-icon name="file-tray-stacked-outline" class="text-accent"></ion-icon>
                  <span>Backlog</span>
                  <span class="badge badge-sm badge-accent" x-text="backlogTasks.length"></span>
                </div>
                <div class="collapse-content p-0">
                  <div id="kanban-backlog" data-column="backlog" class="kanban-column-content space-y-2 p-2 bg-base-200/50 rounded-b-lg min-h-[100px]">
                    <template x-for="task in backlogTasks" :key="task.id">
                      <div :data-id="task.id" class="kanban-task bg-base-100 rounded-lg p-3 cursor-grab active:cursor-grabbing shadow-sm">
                        <div class="flex items-start gap-2">
                          <div class="w-1 h-full min-h-[2rem] rounded-full flex-shrink-0" :style="{ backgroundColor: getTaskPrimaryTag(task)?.color || '#888' }"></div>
                          <div class="flex-1 min-w-0">
                            <p class="font-medium text-sm truncate" x-text="task.title"></p>
                            <div class="flex items-center gap-1 mt-1 flex-wrap">
                              <template x-for="(points, tagId) in task.tagPoints" :key="tagId">
                                <span class="badge badge-xs" :style="{ backgroundColor: getTagById(tagId)?.color + '20', color: getTagById(tagId)?.color }">
                                  <span x-text="points"></span>
                                </span>
                              </template>
                            </div>
                          </div>
                          <button @click.stop="openTaskDetail(task)" class="btn btn-ghost btn-circle btn-xs flex-shrink-0">
                            <ion-icon name="ellipsis-vertical-outline"></ion-icon>
                          </button>
                        </div>
                      </div>
                    </template>
                  </div>
                </div>
              </div>
            </div>

            <!-- This Week (Sprint 0) -->
            <div class="kanban-column">
              <div class="collapse collapse-arrow bg-base-100 shadow-sm md:collapse-open">
                <input type="checkbox" class="md:hidden" checked />
                <div class="collapse-title font-medium flex items-center gap-2 py-3">
                  <ion-icon name="calendar-outline" class="text-primary"></ion-icon>
                  <span>This Week</span>
                  <span class="badge badge-sm badge-primary" x-text="getKanbanSprintTasks(0).length"></span>
                  <span class="badge badge-xs ml-auto"
                        :class="{
                          'badge-success': sprints[0] && getSprintHealth(sprints[0]).overall === 'on_track',
                          'badge-warning': sprints[0] && getSprintHealth(sprints[0]).overall === 'at_risk',
                          'badge-error': sprints[0] && getSprintHealth(sprints[0]).overall === 'off_track'
                        }"
                        x-text="sprints[0] ? getDaysRemaining(sprints[0]) + 'd' : ''"></span>
                </div>
                <div class="collapse-content p-0">
                  <div id="kanban-sprint-0" x-bind:data-column="sprints[0]?.id" class="kanban-column-content space-y-2 p-2 bg-base-200/50 rounded-b-lg min-h-[100px]">
                    <template x-for="task in getKanbanSprintTasks(0)" :key="task.id">
                      <div :data-id="task.id" class="kanban-task bg-base-100 rounded-lg p-3 cursor-grab active:cursor-grabbing shadow-sm" :class="{ 'opacity-50': task.skipState }">
                        <div class="flex items-start gap-2">
                          <button @click.stop="completeTask(task)" class="btn btn-ghost btn-circle btn-xs flex-shrink-0 mt-0.5">
                            <ion-icon name="ellipse-outline" class="text-base"></ion-icon>
                          </button>
                          <div class="w-1 h-full min-h-[2rem] rounded-full flex-shrink-0" :style="{ backgroundColor: getTaskPrimaryTag(task)?.color || '#888' }"></div>
                          <div class="flex-1 min-w-0">
                            <p class="font-medium text-sm truncate" x-text="task.title"></p>
                            <div class="flex items-center gap-1 mt-1 flex-wrap">
                              <template x-for="(points, tagId) in task.tagPoints" :key="tagId">
                                <span class="badge badge-xs" :style="{ backgroundColor: getTagById(tagId)?.color + '20', color: getTagById(tagId)?.color }">
                                  <span x-text="points"></span>
                                </span>
                              </template>
                              <span x-show="task.skipState" class="badge badge-xs badge-warning">skipped</span>
                            </div>
                          </div>
                          <div class="flex flex-col gap-1 flex-shrink-0">
                            <button @click.stop="startSession(task)" :disabled="activeSession" class="btn btn-ghost btn-circle btn-xs text-success">
                              <ion-icon name="play-outline"></ion-icon>
                            </button>
                            <button @click.stop="openTaskDetail(task)" class="btn btn-ghost btn-circle btn-xs">
                              <ion-icon name="ellipsis-vertical-outline"></ion-icon>
                            </button>
                          </div>
                        </div>
                      </div>
                    </template>
                  </div>
                </div>
              </div>
            </div>

            <!-- Next Week (Sprint 1) -->
            <div class="kanban-column">
              <div class="collapse collapse-arrow bg-base-100 shadow-sm md:collapse-open">
                <input type="checkbox" class="md:hidden" />
                <div class="collapse-title font-medium flex items-center gap-2 py-3">
                  <ion-icon name="arrow-forward-outline" class="text-secondary"></ion-icon>
                  <span>Next Week</span>
                  <span class="badge badge-sm badge-secondary" x-text="getKanbanSprintTasks(1).length"></span>
                </div>
                <div class="collapse-content p-0">
                  <div id="kanban-sprint-1" x-bind:data-column="sprints[1]?.id" class="kanban-column-content space-y-2 p-2 bg-base-200/50 rounded-b-lg min-h-[100px]">
                    <template x-for="task in getKanbanSprintTasks(1)" :key="task.id">
                      <div :data-id="task.id" class="kanban-task bg-base-100 rounded-lg p-3 cursor-grab active:cursor-grabbing shadow-sm">
                        <div class="flex items-start gap-2">
                          <div class="w-1 h-full min-h-[2rem] rounded-full flex-shrink-0" :style="{ backgroundColor: getTaskPrimaryTag(task)?.color || '#888' }"></div>
                          <div class="flex-1 min-w-0">
                            <p class="font-medium text-sm truncate" x-text="task.title"></p>
                            <div class="flex items-center gap-1 mt-1 flex-wrap">
                              <template x-for="(points, tagId) in task.tagPoints" :key="tagId">
                                <span class="badge badge-xs" :style="{ backgroundColor: getTagById(tagId)?.color + '20', color: getTagById(tagId)?.color }">
                                  <span x-text="points"></span>
                                </span>
                              </template>
                            </div>
                          </div>
                          <button @click.stop="openTaskDetail(task)" class="btn btn-ghost btn-circle btn-xs flex-shrink-0">
                            <ion-icon name="ellipsis-vertical-outline"></ion-icon>
                          </button>
                        </div>
                      </div>
                    </template>
                  </div>
                </div>
              </div>
            </div>

            <!-- Week After (Sprint 2) -->
            <div class="kanban-column">
              <div class="collapse collapse-arrow bg-base-100 shadow-sm md:collapse-open">
                <input type="checkbox" class="md:hidden" />
                <div class="collapse-title font-medium flex items-center gap-2 py-3">
                  <ion-icon name="play-skip-forward-outline" class="text-info"></ion-icon>
                  <span>Week After</span>
                  <span class="badge badge-sm badge-info" x-text="getKanbanSprintTasks(2).length"></span>
                </div>
                <div class="collapse-content p-0">
                  <div id="kanban-sprint-2" x-bind:data-column="sprints[2]?.id" class="kanban-column-content space-y-2 p-2 bg-base-200/50 rounded-b-lg min-h-[100px]">
                    <template x-for="task in getKanbanSprintTasks(2)" :key="task.id">
                      <div :data-id="task.id" class="kanban-task bg-base-100 rounded-lg p-3 cursor-grab active:cursor-grabbing shadow-sm">
                        <div class="flex items-start gap-2">
                          <div class="w-1 h-full min-h-[2rem] rounded-full flex-shrink-0" :style="{ backgroundColor: getTaskPrimaryTag(task)?.color || '#888' }"></div>
                          <div class="flex-1 min-w-0">
                            <p class="font-medium text-sm truncate" x-text="task.title"></p>
                            <div class="flex items-center gap-1 mt-1 flex-wrap">
                              <template x-for="(points, tagId) in task.tagPoints" :key="tagId">
                                <span class="badge badge-xs" :style="{ backgroundColor: getTagById(tagId)?.color + '20', color: getTagById(tagId)?.color }">
                                  <span x-text="points"></span>
                                </span>
                              </template>
                            </div>
                          </div>
                          <button @click.stop="openTaskDetail(task)" class="btn btn-ghost btn-circle btn-xs flex-shrink-0">
                            <ion-icon name="ellipsis-vertical-outline"></ion-icon>
                          </button>
                        </div>
                      </div>
                    </template>
                  </div>
                </div>
              </div>
            </div>

          </div>
        </div>

      </div>
      <!-- End Page Content -->

    </div>
    <!-- End drawer-content -->

    <!-- Drawer Sidebar -->
    <div class="drawer-side z-20">
      <label for="main-drawer" class="drawer-overlay"></label>
      <div class="menu bg-base-100 min-h-full w-72 p-4">
        <div class="mb-4">
          <h2 class="font-bold text-lg mb-1">Menu</h2>
          <p class="text-sm opacity-60">Settings & more</p>
        </div>

        <!-- Routines Section -->
        <div class="mb-4">
          <p class="text-xs font-medium opacity-50 uppercase mb-2">Active Routine</p>
          <template x-if="activeRoutine">
            <div class="flex items-center gap-2 p-2 rounded-lg" :style="{ backgroundColor: activeRoutine.color + '15' }">
              <span x-text="activeRoutine.icon"></span>
              <span class="font-medium" x-text="activeRoutine.name" :style="{ color: activeRoutine.color }"></span>
              <button @click="clearRoutineOverride()" class="btn btn-ghost btn-xs ml-auto" x-show="manualRoutineId">Clear</button>
            </div>
          </template>
          <template x-if="!activeRoutine">
            <p class="text-sm opacity-50">No active routine</p>
          </template>
        </div>

        <div class="divider my-2"></div>

        <!-- Quick Links -->
        <ul class="menu menu-sm">
          <li><a @click="showTagsModal = true; document.getElementById('main-drawer').checked = false" class="gap-2"><ion-icon name="pricetags-outline"></ion-icon> Manage Tags</a></li>
          <li><a @click="showRoutinesModal = true; document.getElementById('main-drawer').checked = false" class="gap-2"><ion-icon name="time-outline"></ion-icon> Manage Routines</a></li>
          <li><a @click="showSettingsModal = true; document.getElementById('main-drawer').checked = false" class="gap-2"><ion-icon name="settings-outline"></ion-icon> Settings</a></li>
        </ul>

        <div class="divider my-2"></div>

        <!-- Recurring Templates -->
        <div class="mb-4">
          <p class="text-xs font-medium opacity-50 uppercase mb-2">Recurring Tasks</p>
          <div class="space-y-1 max-h-32 overflow-y-auto">
            <template x-for="template in recurringTemplates.slice(0, 5)" :key="template.id">
              <div class="flex items-center gap-2 p-1 text-sm">
                <ion-icon name="repeat-outline" class="text-secondary"></ion-icon>
                <span class="truncate flex-1" x-text="template.title"></span>
              </div>
            </template>
            <template x-if="recurringTemplates.length === 0">
              <p class="text-sm opacity-50">No recurring tasks</p>
            </template>
          </div>
        </div>

        <!-- Completed Summary -->
        <div class="mb-4">
          <p class="text-xs font-medium opacity-50 uppercase mb-2">Recently Completed</p>
          <div class="space-y-1 max-h-32 overflow-y-auto">
            <template x-for="task in completedTasks.slice(0, 5)" :key="task.id">
              <div class="flex items-center gap-2 p-1 text-sm opacity-60">
                <ion-icon name="checkmark-circle-outline" class="text-success"></ion-icon>
                <span class="truncate flex-1 line-through" x-text="task.title"></span>
              </div>
            </template>
            <template x-if="completedTasks.length === 0">
              <p class="text-sm opacity-50">No completed tasks</p>
            </template>
          </div>
        </div>

        <!-- Sprint Health (compact) -->
        <div class="mt-auto pt-4">
          <p class="text-xs font-medium opacity-50 uppercase mb-2">Sprint Health</p>
          <template x-if="selectedSprint">
            <div class="flex items-center gap-2">
              <span class="badge"
                    :class="{
                      'badge-success': getSprintHealth(selectedSprint).overall === 'on_track',
                      'badge-warning': getSprintHealth(selectedSprint).overall === 'at_risk',
                      'badge-error': getSprintHealth(selectedSprint).overall === 'off_track'
                    }"
                    x-text="getSprintHealth(selectedSprint).overall.replace('_', ' ')"></span>
              <span class="text-sm opacity-60" x-text="getDaysRemaining(selectedSprint) + ' days left'"></span>
            </div>
          </template>
        </div>
      </div>
    </div>
  </div>
  <!-- End Drawer -->

  <!-- Bottom Dock Navigation (daisyUI dock component) -->
  <div class="dock dock-sm">
    <button @click="currentView = 'focus'" :class="{ 'dock-active': currentView === 'focus' }">
      <ion-icon name="flash-outline" class="size-[1.2em]"></ion-icon>
      <span class="dock-label">Focus</span>
    </button>
    <button @click="currentView = 'tasks'" :class="{ 'dock-active': currentView === 'tasks' }">
      <ion-icon name="list-outline" class="size-[1.2em]"></ion-icon>
      <span class="dock-label">Tasks</span>
    </button>
  </div>

  <!-- FAB (Floating Action Button) for adding tasks -->
  <div class="fab">
    <button @click="showCreateTaskModal = true" class="btn btn-primary btn-circle btn-lg shadow-lg">
      <ion-icon name="add-outline" class="text-2xl"></ion-icon>
    </button>
  </div>
  
  <!-- ==================== MODALS ==================== -->

  <!-- Create Task Modal -->
  <dialog x-ref="createTaskModal" class="modal" :class="{'modal-open': showCreateTaskModal}">
    <div class="modal-box">
      <form method="dialog">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" @click="showCreateTaskModal = false">âœ•</button>
      </form>
      <h3 class="text-lg font-bold mb-4">Create New Task</h3>
      <form @submit.prevent="createTask()">
        <div class="space-y-4">
          <div class="form-control">
            <label class="label"><span class="label-text">Title *</span></label>
            <input type="text" x-model="newTask.title" required class="input input-bordered w-full" placeholder="What needs to be done?">
          </div>
          <div class="form-control">
            <label class="label"><span class="label-text">Description</span></label>
            <textarea x-model="newTask.description" rows="3" class="textarea textarea-bordered w-full" placeholder="Additional details"></textarea>
          </div>
          <div class="form-control">
            <label class="label"><span class="label-text">Points per Tag *</span></label>
            <div class="space-y-2">
              <template x-for="tag in tags" :key="tag.id">
                <div class="flex items-center gap-3">
                  <div class="flex items-center gap-2 w-32" :style="{ color: tag.color }">
                    <span x-text="tag.icon"></span>
                    <span x-text="tag.name"></span>
                  </div>
                  <select x-model="newTask.tagPoints[tag.id]" class="select select-bordered select-sm">
                    <option value="">-</option>
                    <template x-for="pt in FIBONACCI_POINTS" :key="pt">
                      <option :value="pt" x-text="pt + ' pt'"></option>
                    </template>
                  </select>
                </div>
              </template>
            </div>
            <label class="label"><span class="label-text-alt">Select at least one tag with points</span></label>
          </div>
          <!-- Recurrence preview -->
          <template x-if="parseRecurrence(newTask.title).valid">
            <div class="alert alert-info py-2">
              <ion-icon name="repeat-outline"></ion-icon>
              <span>Repeats <span x-text="parseRecurrence(newTask.title).description"></span></span>
            </div>
          </template>
        </div>
        <div class="modal-action">
          <button type="button" @click="showCreateTaskModal = false" class="btn btn-ghost">Cancel</button>
          <button type="submit" class="btn btn-primary" x-text="parseRecurrence(newTask.title).valid ? 'Create Recurring Task' : 'Create Task'"></button>
        </div>
      </form>
    </div>
    <form method="dialog" class="modal-backdrop" @click="showCreateTaskModal = false"><button>close</button></form>
  </dialog>

  <!-- Task Detail Modal -->
  <dialog x-ref="taskDetailModal" class="modal" :class="{'modal-open': showTaskDetailModal}">
    <div class="modal-box max-w-2xl">
      <form method="dialog">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" @click="showTaskDetailModal = false; saveTaskDetail()">âœ•</button>
      </form>
      <template x-if="selectedTask">
        <div>
          <div class="flex items-start gap-2 mb-4">
            <ion-icon x-show="selectedTask.status === 'completed'" name="checkmark-circle-outline" class="text-success text-xl mt-1"></ion-icon>
            <ion-icon x-show="selectedTask.status === 'canceled'" name="close-circle-outline" class="text-error text-xl mt-1"></ion-icon>
            <ion-icon x-show="selectedTask.recurrence" name="repeat-outline" class="text-secondary text-xl mt-1"></ion-icon>
            <div class="flex-1">
              <input type="text" x-model="selectedTask.title" @change="saveTaskDetail()"
                     class="input input-ghost text-xl font-bold w-full p-0 h-auto focus:bg-base-200"
                     :disabled="selectedTask.status !== 'active'">
              <div class="flex items-center gap-2 text-sm opacity-60 mt-1">
                <span x-text="'Created ' + formatDate(new Date(selectedTask.createdAt))"></span>
                <span>â€¢</span>
                <span x-text="getTaskAge(selectedTask) + ' days old'"></span>
              </div>
            </div>
          </div>

          <!-- Description -->
          <div class="form-control mb-6">
            <label class="label"><span class="label-text">Description</span></label>
            <textarea x-model="selectedTask.description" @change="saveTaskDetail()" rows="3"
                      class="textarea textarea-bordered w-full" placeholder="Add description..."
                      :disabled="selectedTask.status !== 'active'"></textarea>
          </div>

          <!-- Tags & Points -->
          <div class="mb-6">
            <label class="label"><span class="label-text">Tags & Points</span></label>
            <div class="flex flex-wrap gap-2">
              <template x-for="(points, tagId) in selectedTask.tagPoints" :key="tagId">
                <div class="badge badge-lg gap-1" :style="{ backgroundColor: getTagById(tagId)?.color + '20', color: getTagById(tagId)?.color, borderColor: getTagById(tagId)?.color }">
                  <span x-text="getTagById(tagId)?.icon"></span>
                  <span x-text="getTagById(tagId)?.name"></span>
                  <select x-model="selectedTask.tagPoints[tagId]" @change="saveTaskDetail()"
                          class="bg-transparent border-none text-sm font-bold w-14"
                          :disabled="selectedTask.status !== 'active'">
                    <template x-for="pt in FIBONACCI_POINTS" :key="pt">
                      <option :value="pt" x-text="pt + 'pt'"></option>
                    </template>
                  </select>
                </div>
              </template>
            </div>
          </div>
          
          <!-- Recurrence Info -->
          <template x-if="selectedTask.recurrence">
            <div class="mb-6 p-4 bg-secondary/10 rounded-lg">
              <label class="block text-sm font-medium text-secondary mb-1 flex items-center gap-1"><ion-icon name="repeat-outline"></ion-icon> Recurrence Pattern</label>
              <p class="text-secondary" x-text="describeRRule(selectedTask.recurrence)"></p>
              <p class="text-xs opacity-70 mt-1">Next: <span x-text="formatDate(getNextOccurrence(selectedTask))"></span></p>
            </div>
          </template>
          
          <!-- Sessions -->
          <div class="mb-6">
            <div class="flex items-center justify-between mb-2">
              <label class="label-text font-medium">Focus Sessions</label>
              <button @click="startSession(selectedTask); showTaskDetailModal = false"
                      :disabled="activeSession || selectedTask.status !== 'active'"
                      class="btn btn-ghost btn-xs text-primary">+ Start Session</button>
            </div>
            <div class="space-y-2 max-h-40 overflow-y-auto">
              <template x-for="session in (selectedTask.sessions || []).slice().reverse()" :key="session.id">
                <div class="bg-base-200 rounded-lg p-3 text-sm">
                  <div class="flex items-center justify-between">
                    <div class="flex items-center gap-2">
                      <ion-icon :class="{'text-success': session.status === 'completed', 'text-error': session.status === 'abandoned', 'text-info': session.status === 'in_progress'}"
                            :name="session.status === 'completed' ? 'checkmark-outline' : session.status === 'abandoned' ? 'close-outline' : 'play-outline'"></ion-icon>
                      <span x-text="formatDate(new Date(session.startedAt))"></span>
                      <template x-if="session.endedAt">
                        <span class="opacity-60" x-text="'(' + formatSessionTime(Math.floor((new Date(session.endedAt) - new Date(session.startedAt)) / 1000)) + ')'"></span>
                      </template>
                    </div>
                    <template x-if="session.focusLevel">
                      <span class="badge badge-sm"
                            :class="{'badge-success': session.focusLevel === 'focused', 'badge-warning': session.focusLevel === 'neutral', 'badge-error': session.focusLevel === 'distracted'}"
                            x-text="session.focusLevel"></span>
                    </template>
                  </div>
                </div>
              </template>
              <template x-if="!selectedTask.sessions?.length">
                <p class="text-sm opacity-50 italic">No sessions yet</p>
              </template>
            </div>
          </div>
          
          <!-- Comments -->
          <div class="mb-6">
            <label class="label-text font-medium mb-2 block">Comments</label>
            <div class="space-y-2 mb-3 max-h-48 overflow-y-auto">
              <template x-for="comment in (selectedTask.comments || [])" :key="comment.id">
                <div class="bg-base-200 rounded-lg p-3" :class="comment.skipJustification ? 'border-l-4 border-l-warning' : ''">
                  <div class="flex items-start justify-between">
                    <div class="flex-1">
                      <template x-if="comment.skipJustification">
                        <span class="badge badge-warning badge-sm mb-1">Skip Justification</span>
                      </template>
                      <p class="text-sm whitespace-pre-wrap" x-text="comment.content"></p>
                      <p class="text-xs opacity-50 mt-1" x-text="formatDate(new Date(comment.createdAt))"></p>
                    </div>
                    <button @click="deleteComment(selectedTask, comment)" class="btn btn-ghost btn-xs text-error"><ion-icon name="trash-outline"></ion-icon></button>
                  </div>
                </div>
              </template>
            </div>
            <div class="flex gap-2">
              <input type="text" x-model="newCommentContent" @keyup.enter="addComment(selectedTask)"
                     class="input input-bordered input-sm flex-1" placeholder="Add a comment...">
              <button @click="addComment(selectedTask)" class="btn btn-ghost btn-sm">Add</button>
            </div>
          </div>
          
          <!-- Location & Parent -->
          <div class="text-sm opacity-70">
            <p class="flex items-center gap-1">Location: <span class="font-medium flex items-center gap-1"><ion-icon :name="selectedTask.location.type === 'backlog' ? 'clipboard-outline' : 'calendar-outline'"></ion-icon> <span x-text="selectedTask.location.type === 'backlog' ? 'Backlog' : 'Sprint'"></span></span></p>
            <template x-if="selectedTask.parentId">
              <p class="mt-1 flex items-center gap-1">
                <ion-icon name="repeat-outline"></ion-icon> Instance of:
                <span class="font-medium" x-text="getTaskById(selectedTask.parentId)?.title"></span>
              </p>
            </template>
          </div>
        </div>
      </template>
    </div>
    <form method="dialog" class="modal-backdrop" @click="showTaskDetailModal = false; saveTaskDetail()"><button>close</button></form>
  </dialog>
  
  <!-- Skip For Day Modal -->
  <dialog class="modal" :class="{'modal-open': showSkipForDayModal}">
    <div class="modal-box">
      <form method="dialog">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" @click="showSkipForDayModal = false">âœ•</button>
      </form>
      <h3 class="text-lg font-bold mb-2">Skip for Day</h3>
      <p class="opacity-70 mb-4">This task will be hidden until tomorrow. Please provide a justification.</p>
      <div class="form-control mb-4">
        <label class="label"><span class="label-text">Justification *</span></label>
        <textarea x-model="skipJustification" required rows="3" class="textarea textarea-bordered" placeholder="Why are you skipping this task?"></textarea>
      </div>
      <div class="modal-action">
        <button @click="showSkipForDayModal = false" class="btn btn-ghost">Cancel</button>
        <button @click="confirmSkipForDay()" :disabled="!skipJustification.trim()" class="btn btn-warning">Skip Task</button>
      </div>
    </div>
    <form method="dialog" class="modal-backdrop" @click="showSkipForDayModal = false"><button>close</button></form>
  </dialog>
  
  <!-- Complete Session Modal -->
  <dialog class="modal" :class="{'modal-open': showCompleteSessionModal}">
    <div class="modal-box">
      <form method="dialog">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" @click="showCompleteSessionModal = false">âœ•</button>
      </form>
      <h3 class="text-lg font-bold mb-4">Complete Session</h3>
      <div class="mb-4">
        <label class="label"><span class="label-text">How focused were you?</span></label>
        <div class="flex gap-2">
          <button type="button" @click="sessionFocusLevel = 'distracted'"
                  class="btn btn-sm flex-1" :class="sessionFocusLevel === 'distracted' ? 'btn-error' : 'btn-ghost bg-error/10 text-error'">
            <ion-icon name="sad-outline"></ion-icon> Distracted
          </button>
          <button type="button" @click="sessionFocusLevel = 'neutral'"
                  class="btn btn-sm flex-1" :class="sessionFocusLevel === 'neutral' ? 'btn-warning' : 'btn-ghost bg-warning/10 text-warning'">
            <ion-icon name="ellipse-outline"></ion-icon> Neutral
          </button>
          <button type="button" @click="sessionFocusLevel = 'focused'"
                  class="btn btn-sm flex-1" :class="sessionFocusLevel === 'focused' ? 'btn-success' : 'btn-ghost bg-success/10 text-success'">
            <ion-icon name="radio-button-on-outline"></ion-icon> Focused
          </button>
        </div>
      </div>
      <div class="form-control mb-4">
        <label class="label"><span class="label-text">Session Note (optional)</span></label>
        <textarea x-model="sessionNote" rows="2" class="textarea textarea-bordered" placeholder="What did you accomplish?"></textarea>
      </div>
      <div class="form-control mb-4">
        <label class="label cursor-pointer justify-start gap-2">
          <input type="checkbox" x-model="markTaskComplete" class="checkbox checkbox-sm">
          <span class="label-text">Also mark task as complete</span>
        </label>
      </div>
      <div class="modal-action">
        <button @click="showCompleteSessionModal = false" class="btn btn-ghost">Cancel</button>
        <button @click="confirmCompleteSession()" class="btn btn-success">Complete Session</button>
      </div>
    </div>
    <form method="dialog" class="modal-backdrop" @click="showCompleteSessionModal = false"><button>close</button></form>
  </dialog>
  
  <!-- Sprint Health Modal -->
  <dialog class="modal" :class="{'modal-open': showSprintHealthModal}">
    <div class="modal-box max-w-lg">
      <form method="dialog">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" @click="showSprintHealthModal = false">âœ•</button>
      </form>
      <h3 class="text-lg font-bold mb-4">Sprint Health Details</h3>
      <template x-if="selectedSprint">
        <div class="space-y-4">
          <template x-for="tag in tags" :key="tag.id">
            <div class="p-4 rounded-lg"
                 :class="{'bg-success/10': getTagHealth(selectedSprint, tag.id) === 'on_track', 'bg-warning/10': getTagHealth(selectedSprint, tag.id) === 'at_risk', 'bg-error/10': getTagHealth(selectedSprint, tag.id) === 'off_track'}">
              <div class="flex items-center justify-between mb-2">
                <div class="flex items-center gap-2">
                  <span x-text="tag.icon"></span>
                  <span class="font-medium" x-text="tag.name"></span>
                </div>
                <span class="badge"
                      :class="{'badge-success': getTagHealth(selectedSprint, tag.id) === 'on_track', 'badge-warning': getTagHealth(selectedSprint, tag.id) === 'at_risk', 'badge-error': getTagHealth(selectedSprint, tag.id) === 'off_track'}"
                      x-text="getTagHealth(selectedSprint, tag.id).replace('_', ' ')"></span>
              </div>
              <div class="grid grid-cols-2 gap-2 text-sm">
                <div><span class="opacity-60">Assigned:</span> <span class="font-medium" x-text="getSprintPointsForTag(selectedSprint, tag.id) + ' pts'"></span></div>
                <div><span class="opacity-60">Capacity:</span> <span class="font-medium" x-text="getCapacityForTag(selectedSprint, tag.id) + ' pts'"></span></div>
                <div><span class="opacity-60">Burn rate:</span> <span class="font-medium" x-text="getBurnRateNeeded(selectedSprint, tag.id).toFixed(1) + ' pts/day'"></span></div>
                <div><span class="opacity-60">Sustainable:</span> <span class="font-medium" x-text="(getCapacityForTag(selectedSprint, tag.id) / 7).toFixed(1) + ' pts/day'"></span></div>
              </div>
            </div>
          </template>
        </div>
      </template>
      <div class="modal-action">
        <button @click="showSprintHealthModal = false" class="btn btn-ghost">Close</button>
      </div>
    </div>
    <form method="dialog" class="modal-backdrop" @click="showSprintHealthModal = false"><button>close</button></form>
  </dialog>
  
  <!-- Capacity Edit Modal -->
  <dialog class="modal" :class="{'modal-open': showCapacityEditModal}">
    <div class="modal-box max-w-sm">
      <form method="dialog">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" @click="showCapacityEditModal = false">âœ•</button>
      </form>
      <h3 class="text-lg font-bold mb-4">Edit Capacity</h3>
      <template x-if="capacityEditTag">
        <div>
          <div class="flex items-center gap-2 mb-4" :style="{ color: capacityEditTag.color }">
            <span x-text="capacityEditTag.icon" class="text-2xl"></span>
            <span class="font-medium" x-text="capacityEditTag.name"></span>
          </div>
          <div class="form-control mb-4">
            <label class="label"><span class="label-text">Capacity for this sprint</span></label>
            <input type="number" x-model.number="capacityEditValue" min="1" class="input input-bordered">
            <label class="label"><span class="label-text-alt">Default: <span x-text="capacityEditTag.defaultCapacity"></span> points</span></label>
          </div>
          <div class="modal-action">
            <button @click="showCapacityEditModal = false" class="btn btn-ghost">Cancel</button>
            <button @click="saveCapacityOverride()" class="btn btn-primary">Save</button>
          </div>
        </div>
      </template>
    </div>
    <form method="dialog" class="modal-backdrop" @click="showCapacityEditModal = false"><button>close</button></form>
  </dialog>
  
  <!-- Tags Management Modal -->
  <dialog class="modal" :class="{'modal-open': showTagsModal}">
    <div class="modal-box max-w-lg max-h-[90vh]">
      <form method="dialog">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" @click="showTagsModal = false">âœ•</button>
      </form>
      <h3 class="text-lg font-bold mb-4">Manage Tags</h3>
      <div class="space-y-3 mb-6">
        <template x-for="tag in tags" :key="tag.id">
          <div class="flex items-center gap-3 p-3 bg-base-200 rounded-lg">
            <input type="text" x-model="tag.icon" @change="updateTag(tag)" class="input input-ghost w-12 text-center text-xl p-0">
            <div class="flex-1">
              <input type="text" x-model="tag.name" @change="updateTag(tag)" class="input input-ghost font-medium p-0 h-auto w-full" :style="{ color: tag.color }">
              <div class="flex items-center gap-2 mt-1">
                <input type="color" x-model="tag.color" @change="updateTag(tag)" class="w-6 h-6 rounded cursor-pointer">
                <span class="text-xs opacity-60">Cap:</span>
                <input type="number" x-model.number="tag.defaultCapacity" @change="updateTag(tag)" class="input input-bordered input-xs w-16" min="1">
              </div>
            </div>
            <button @click="deleteTag(tag)" :disabled="tag.id === 'untagged'" class="btn btn-ghost btn-sm text-error disabled:opacity-30"><ion-icon name="trash-outline"></ion-icon></button>
          </div>
        </template>
      </div>
      <div class="divider"></div>
      <h4 class="font-medium mb-3">Add New Tag</h4>
      <div class="flex items-center gap-2 flex-wrap">
        <input type="text" x-model="newTagIcon" class="input input-bordered w-12 text-center" placeholder="ðŸ“Œ">
        <input type="text" x-model="newTagName" class="input input-bordered flex-1 min-w-32" placeholder="Tag name">
        <input type="color" x-model="newTagColor" class="w-10 h-10 rounded cursor-pointer">
        <input type="number" x-model.number="newTagCapacity" class="input input-bordered w-16" placeholder="Cap" min="1">
        <button @click="addTag()" :disabled="!newTagName.trim()" class="btn btn-primary">Add</button>
      </div>
    </div>
    <form method="dialog" class="modal-backdrop" @click="showTagsModal = false"><button>close</button></form>
  </dialog>
  
  <!-- Routines Management Modal -->
  <dialog class="modal" :class="{'modal-open': showRoutinesModal}">
    <div class="modal-box max-w-2xl max-h-[90vh]">
      <form method="dialog">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" @click="showRoutinesModal = false">âœ•</button>
      </form>
      <h3 class="text-lg font-bold mb-2">Manage Routines</h3>
      <p class="text-sm opacity-70 mb-4">Routines auto-filter tasks based on time. Higher priority wins when multiple match.</p>
      <div class="space-y-3 mb-6">
        <template x-for="routine in routines" :key="routine.id">
          <div class="p-4 bg-base-200 rounded-lg">
            <div class="flex items-start justify-between gap-4">
              <div class="flex-1">
                <div class="flex items-center gap-2 mb-2">
                  <input type="text" x-model="routine.icon" @change="updateRoutine(routine)" class="input input-ghost w-10 text-center p-0">
                  <input type="text" x-model="routine.name" @change="updateRoutine(routine)" class="input input-ghost font-medium p-0 h-auto" :style="{ color: routine.color }">
                  <span class="text-xs opacity-60">Priority:</span>
                  <input type="number" x-model.number="routine.priority" @change="updateRoutine(routine)" class="input input-bordered input-xs w-14" min="1" max="10">
                </div>
                <div class="grid grid-cols-2 gap-2 text-sm">
                  <div class="form-control">
                    <label class="label py-0"><span class="label-text-alt">Task Filter</span></label>
                    <input type="text" x-model="routine.taskFilterExpression" @change="updateRoutine(routine)" class="input input-bordered input-sm" placeholder="hasTag('work')">
                  </div>
                  <div class="form-control">
                    <label class="label py-0"><span class="label-text-alt">Activation</span></label>
                    <input type="text" x-model="routine.activationExpression" @change="updateRoutine(routine)" class="input input-bordered input-sm" placeholder="isWeekday">
                  </div>
                </div>
              </div>
              <div class="flex items-center gap-1">
                <input type="color" x-model="routine.color" @change="updateRoutine(routine)" class="w-8 h-8 rounded cursor-pointer">
                <button @click="deleteRoutine(routine)" class="btn btn-ghost btn-sm text-error"><ion-icon name="trash-outline"></ion-icon></button>
              </div>
            </div>
          </div>
        </template>
        <template x-if="routines.length === 0">
          <p class="text-center opacity-50 py-4">No routines yet</p>
        </template>
      </div>
      <div class="divider"></div>
      <h4 class="font-medium mb-3">Add New Routine</h4>
      <div class="grid grid-cols-2 gap-3 mb-3">
        <div class="flex items-center gap-2">
          <input type="text" x-model="newRoutineIcon" class="input input-bordered w-12 text-center" placeholder="ðŸ ">
          <input type="text" x-model="newRoutineName" class="input input-bordered flex-1" placeholder="Routine name">
        </div>
        <div class="flex items-center gap-2">
          <input type="color" x-model="newRoutineColor" class="w-10 h-10 rounded cursor-pointer">
          <input type="number" x-model.number="newRoutinePriority" class="input input-bordered w-16" placeholder="Pri" min="1" max="10">
        </div>
        <input type="text" x-model="newRoutineFilter" class="input input-bordered" placeholder="Task filter (e.g., hasTag('work'))">
        <input type="text" x-model="newRoutineActivation" class="input input-bordered" placeholder="Activation (e.g., isWeekday)">
      </div>
      <div class="flex justify-end mb-4">
        <button @click="addRoutine()" :disabled="!newRoutineName.trim()" class="btn btn-primary">Add Routine</button>
      </div>
      <div class="alert alert-info">
        <div>
          <p class="font-medium mb-1">Expression Examples:</p>
          <div class="grid grid-cols-2 gap-2 text-xs font-mono">
            <div>hasTag("Work")</div>
            <div>isWeekday and hour >= 9</div>
            <div>age > 7</div>
            <div>dayOfWeek == "mon"</div>
          </div>
        </div>
      </div>
    </div>
    <form method="dialog" class="modal-backdrop" @click="showRoutinesModal = false"><button>close</button></form>
  </dialog>
  
  <!-- Settings Modal -->
  <dialog class="modal" :class="{'modal-open': showSettingsModal}">
    <div class="modal-box max-w-md">
      <form method="dialog">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" @click="showSettingsModal = false">âœ•</button>
      </form>
      <h3 class="text-lg font-bold mb-4">Settings</h3>
      <div class="space-y-4">
        <div class="form-control">
          <label class="label"><span class="label-text">Default Session Duration</span></label>
          <select x-model.number="settings.defaultSessionDuration" class="select select-bordered w-full">
            <option value="15">15 minutes</option>
            <option value="25">25 minutes (Pomodoro)</option>
            <option value="45">45 minutes</option>
            <option value="60">60 minutes</option>
          </select>
        </div>
        <div class="divider"></div>
        <div>
          <h4 class="font-medium text-error mb-2">Danger Zone</h4>
          <button @click="resetAllData()" class="btn btn-error btn-outline w-full gap-2"><ion-icon name="trash-outline"></ion-icon> Reset All Data</button>
        </div>
      </div>
    </div>
    <form method="dialog" class="modal-backdrop" @click="showSettingsModal = false"><button>close</button></form>
  </dialog>
  
  <script>
    function checkMate() {
      return {
        // === CONSTANTS ===
        FIBONACCI_POINTS: [1, 2, 3, 5, 8, 13, 21],
        DAYS: ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'],
        
        // === STATE (persisted) ===
        tasks: Alpine.$persist([]).as('checkmate_tasks'),
        tags: Alpine.$persist([]).as('checkmate_tags'),
        sprints: Alpine.$persist([]).as('checkmate_sprints'),
        routines: Alpine.$persist([]).as('checkmate_routines'),
        settings: Alpine.$persist({ defaultSessionDuration: 25, theme: 'light' }).as('checkmate_settings'),
        
        // === UI STATE ===
        currentView: 'focus',
        selectedSprintIndex: 0,
        selectedTagFilters: [],
        manualRoutineId: '',
        today: new Date(),
        
        // === MODAL STATE ===
        showCreateTaskModal: false,
        showTaskDetailModal: false,
        showSkipForDayModal: false,
        showCompleteSessionModal: false,
        showSprintHealthModal: false,
        showCapacityEditModal: false,
        showTagsModal: false,
        showRoutinesModal: false,
        showSettingsModal: false,
        
        // === FORM STATE ===
        newTask: { title: '', description: '', tagPoints: {} },
        selectedTask: null,
        newCommentContent: '',
        skipJustification: '',
        taskToSkip: null,
        sessionFocusLevel: 'neutral',
        sessionNote: '',
        markTaskComplete: false,
        capacityEditSprint: null,
        capacityEditTag: null,
        capacityEditValue: 0,
        newTagName: '',
        newTagIcon: 'ðŸ“Œ',
        newTagColor: '#6366f1',
        newTagCapacity: 20,
        newRoutineName: '',
        newRoutineIcon: 'ðŸ ',
        newRoutineColor: '#6366f1',
        newRoutinePriority: 5,
        newRoutineFilter: '',
        newRoutineActivation: '',
        
        // === SESSION TRACKING ===
        activeSession: null,
        sessionElapsed: 0,
        sessionInterval: null,
        
        // === COMPUTED PROPERTIES ===
        get selectedSprint() {
          return this.sprints[this.selectedSprintIndex];
        },
        
        get backlogTasks() {
          return this.tasks.filter(t => t.location.type === 'backlog' && t.status === 'active' && !t.recurrence);
        },
        
        get filteredBacklogTasks() {
          let tasks = this.backlogTasks;
          if (this.selectedTagFilters.length > 0) {
            tasks = tasks.filter(t => Object.keys(t.tagPoints).some(tagId => this.selectedTagFilters.includes(tagId)));
          }
          if (this.activeRoutine) {
            tasks = tasks.filter(t => this.evaluateTaskFilter(t, this.activeRoutine.taskFilterExpression));
          }
          return tasks;
        },
        
        get recurringTemplates() {
          return this.tasks.filter(t => t.recurrence && t.status === 'active');
        },
        
        get completedTasks() {
          return this.tasks.filter(t => t.status === 'completed' || t.status === 'canceled');
        },
        
        get activeRoutine() {
          if (this.manualRoutineId) {
            return this.routines.find(r => r.id === this.manualRoutineId);
          }
          const matching = this.routines.filter(r => this.evaluateActivationExpression(r.activationExpression));
          if (matching.length === 0) return null;
          matching.sort((a, b) => {
            if (b.priority !== a.priority) return b.priority - a.priority;
            return a.name.localeCompare(b.name);
          });
          return matching[0];
        },

        // Tasks in current sprint (today's focus)
        get todayTasks() {
          const sprint = this.sprints[0]; // Current sprint
          if (!sprint) return [];
          return this.tasks.filter(t =>
            t.location.type === 'sprint' &&
            t.location.sprintId === sprint.id &&
            t.status === 'active' &&
            !t.recurrence
          ).sort((a, b) => {
            // Returned tasks bubble to top
            if (a.skipState?.type === 'for_day' && a.skipState?.returned) return -1;
            if (b.skipState?.type === 'for_day' && b.skipState?.returned) return 1;
            // Skipped tasks go to bottom
            if (a.skipState && !b.skipState) return 1;
            if (b.skipState && !a.skipState) return -1;
            return (a.order || 0) - (b.order || 0);
          });
        },

        // Tasks in next sprint (this week) - kept for compatibility
        get thisWeekTasks() {
          const sprint = this.sprints[1]; // Next sprint
          if (!sprint) return [];
          return this.tasks.filter(t =>
            t.location.type === 'sprint' &&
            t.location.sprintId === sprint.id &&
            t.status === 'active' &&
            !t.recurrence
          );
        },

        // Get tasks for a specific sprint by index (for Kanban)
        getKanbanSprintTasks(sprintIndex) {
          const sprint = this.sprints[sprintIndex];
          if (!sprint) return [];
          return this.tasks.filter(t =>
            t.location.type === 'sprint' &&
            t.location.sprintId === sprint.id &&
            t.status === 'active' &&
            !t.recurrence
          ).sort((a, b) => (a.order || 0) - (b.order || 0));
        },

        // The #1 priority task to focus on
        get focusTask() {
          const tasks = this.todayTasks.filter(t => !t.skipState || (t.skipState?.type === 'for_day' && t.skipState?.returned));
          return tasks[0] || null;
        },

        // Tasks after the focus task
        get upNextTasks() {
          const tasks = this.todayTasks.filter(t => !t.skipState || (t.skipState?.type === 'for_day' && t.skipState?.returned));
          return tasks.slice(1);
        },

        // === LIFECYCLE ===
        init() {
          this.initializeDefaults();
          this.initializeSprints();
          setInterval(() => {
            this.today = new Date();
            this.checkSkipReturns();
          }, 60000);
          this.checkSkipReturns();
          console.log('Check Mate initialized');
        },

        // Initialize Kanban drag-and-drop with SortableJS
        kanbanInstances: [],
        initKanban() {
          // Destroy existing instances
          this.kanbanInstances.forEach(instance => instance.destroy());
          this.kanbanInstances = [];

          const self = this;
          const columnIds = ['kanban-backlog', 'kanban-sprint-0', 'kanban-sprint-1', 'kanban-sprint-2'];

          columnIds.forEach(columnId => {
            const el = document.getElementById(columnId);
            if (!el) return;

            const sortable = new Sortable(el, {
              group: 'kanban-tasks',
              animation: 150,
              ghostClass: 'sortable-ghost',
              chosenClass: 'sortable-chosen',
              dragClass: 'sortable-drag',
              handle: '.kanban-task', // Entire card is draggable
              draggable: '.kanban-task',
              // Disable fallback mode which causes clone issues
              forceFallback: false,

              onEnd: function(evt) {
                const taskId = evt.item.dataset.id;
                if (!taskId) {
                  console.warn('No task ID found on dragged item');
                  return;
                }

                const task = self.tasks.find(t => t.id === taskId);
                if (!task) {
                  console.warn('Task not found:', taskId);
                  return;
                }

                const toColumn = evt.to.dataset.column;
                const newIndex = evt.newIndex;

                console.log('Kanban move:', taskId, 'to', toColumn, 'at index', newIndex);

                // Update task location
                if (toColumn === 'backlog') {
                  task.location = { type: 'backlog' };
                  task.skipState = null;
                } else {
                  // toColumn is a sprint ID
                  task.location = { type: 'sprint', sprintId: toColumn };
                  task.skipState = null;
                }

                // Update order within the column
                const columnEl = evt.to;
                const taskElements = columnEl.querySelectorAll('.kanban-task[data-id]');
                taskElements.forEach((el, idx) => {
                  const id = el.dataset.id;
                  const t = self.tasks.find(task => task.id === id);
                  if (t) t.order = idx;
                });

                // Trigger Alpine reactivity
                self.tasks = [...self.tasks];
              }
            });

            self.kanbanInstances.push(sortable);
          });

          console.log('Kanban initialized with', this.kanbanInstances.length, 'columns');
        },
        
        initializeDefaults() {
          if (this.tags.length === 0) {
            this.tags = [
              { id: 'untagged', name: 'Untagged', icon: 'ðŸ“¦', color: '#6b7280', defaultCapacity: 10, description: '' },
              { id: this.generateId(), name: 'Work', icon: 'ðŸ’¼', color: '#3b82f6', defaultCapacity: 25, description: 'Work tasks' },
              { id: this.generateId(), name: 'Personal', icon: 'ðŸ ', color: '#22c55e', defaultCapacity: 15, description: 'Personal tasks' },
              { id: this.generateId(), name: 'Health', icon: 'â¤ï¸', color: '#ef4444', defaultCapacity: 10, description: 'Health & fitness' },
              { id: this.generateId(), name: 'Learning', icon: 'ðŸ“š', color: '#8b5cf6', defaultCapacity: 10, description: 'Learning & growth' },
            ];
          }
          
          if (this.routines.length === 0) {
            this.routines = [
              { id: this.generateId(), name: 'Work Hours', icon: 'ðŸ’¼', color: '#3b82f6', priority: 8, taskFilterExpression: 'hasTag("Work")', activationExpression: 'isWeekday and hour >= 9 and hour < 18' },
              { id: this.generateId(), name: 'Evening', icon: 'ðŸŒ™', color: '#8b5cf6', priority: 5, taskFilterExpression: 'hasAnyTag("Personal", "Health")', activationExpression: 'hour >= 18 or hour < 9' },
              { id: this.generateId(), name: 'Weekend', icon: 'â˜€ï¸', color: '#f59e0b', priority: 7, taskFilterExpression: 'hasAnyTag("Personal", "Health", "Learning")', activationExpression: 'isWeekend' }
            ];
          }
        },
        
        initializeSprints() {
          const now = new Date();
          const currentSunday = this.getStartOfWeek(now);
          
          const requiredStarts = [currentSunday, this.addDays(currentSunday, 7), this.addDays(currentSunday, 14)];
          
          requiredStarts.forEach((startDate) => {
            const exists = this.sprints.find(s => new Date(s.startDate).toDateString() === startDate.toDateString());
            if (!exists) {
              this.sprints.push({
                id: this.generateId(),
                startDate: startDate.toISOString(),
                endDate: this.addDays(startDate, 6).toISOString(),
                capacityOverrides: {},
                taskIds: []
              });
            }
          });
          
          this.sprints.sort((a, b) => new Date(a.startDate) - new Date(b.startDate));
          
          const currentIndex = this.sprints.findIndex(s => new Date(s.startDate).toDateString() === currentSunday.toDateString());
          
          if (currentIndex > 0) {
            this.sprints.slice(0, currentIndex).forEach(pastSprint => {
              this.tasks.filter(t => t.location.type === 'sprint' && t.location.sprintId === pastSprint.id)
                .forEach(task => {
                  task.location = { type: 'backlog' };
                  task.sprintHistory = task.sprintHistory || [];
                  task.sprintHistory.push(pastSprint.id);
                });
            });
            this.sprints = this.sprints.slice(currentIndex, currentIndex + 3);
          }
          
          if (this.sprints.length > 3) {
            this.sprints = this.sprints.slice(0, 3);
          }
        },
        
        // === HELPER FUNCTIONS ===
        generateId() {
          return 'id_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
        },
        
        getTagById(tagId) {
          return this.tags.find(t => t.id === tagId);
        },
        
        getTaskById(taskId) {
          return this.tasks.find(t => t.id === taskId);
        },
        
        getTaskPrimaryTag(task) {
          const firstTagId = Object.keys(task.tagPoints)[0];
          return this.getTagById(firstTagId);
        },
        
        getTaskAge(task) {
          const created = new Date(task.createdAt);
          const diff = this.today - created;
          return Math.floor(diff / (1000 * 60 * 60 * 24));
        },
        
        formatDate(date) {
          if (!date) return '';
          const d = new Date(date);
          return d.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
        },
        
        formatSessionTime(seconds) {
          const mins = Math.floor(seconds / 60);
          const secs = seconds % 60;
          return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        },
        
        getStartOfWeek(date) {
          const d = new Date(date);
          const day = d.getDay();
          d.setDate(d.getDate() - day);
          d.setHours(0, 0, 0, 0);
          return d;
        },
        
        addDays(date, days) {
          const d = new Date(date);
          d.setDate(d.getDate() + days);
          return d;
        },
        
        checkSkipReturns() {
          const now = new Date();
          this.tasks.forEach(task => {
            if (task.skipState?.type === 'for_day' && new Date(task.skipState.returnAt) <= now) {
              task.skipState.returned = true;
            }
          });
        },
        
        // === EXPRESSION EVALUATOR ===
        evaluateTaskFilter(task, expression) {
          if (!expression || expression.trim() === '' || expression === 'true') return true;
          if (expression === 'false') return false;
          
          try {
            const tagIds = Object.keys(task.tagPoints);
            const tagNames = tagIds.map(id => this.getTagById(id)?.name?.toLowerCase()).filter(Boolean);
            
            const context = {
              title: task.title,
              description: task.description || '',
              status: task.status,
              age: this.getTaskAge(task),
              sprintCount: task.sprintHistory?.length || 0,
              inBacklog: task.location.type === 'backlog',
              inSprint: task.location.type === 'sprint',
              points: Object.values(task.tagPoints).reduce((a, b) => a + b, 0)
            };
            
            const funcs = {
              hasTag: (name) => tagNames.includes(name.toLowerCase()),
              hasAnyTag: (...names) => names.some(n => tagNames.includes(n.toLowerCase())),
              hasAllTags: (...names) => names.every(n => tagNames.includes(n.toLowerCase()))
            };
            
            return this.safeEval(expression, context, funcs);
          } catch (e) {
            console.error('Task filter eval error:', e, expression);
            return true;
          }
        },
        
        evaluateActivationExpression(expression) {
          if (!expression || expression.trim() === '' || expression === 'false') return false;
          if (expression === 'true') return true;
          
          try {
            const now = this.today;
            const context = {
              hour: now.getHours(),
              minute: now.getMinutes(),
              dayOfWeek: this.DAYS[now.getDay()],
              date: now.getDate(),
              month: now.getMonth() + 1,
              year: now.getFullYear(),
              isWeekday: now.getDay() > 0 && now.getDay() < 6,
              isWeekend: now.getDay() === 0 || now.getDay() === 6,
              time: now.getHours() * 60 + now.getMinutes()
            };
            
            return this.safeEval(expression, context, {});
          } catch (e) {
            console.error('Activation eval error:', e, expression);
            return false;
          }
        },
        
        // Safe expression evaluation using Filtrex (no eval!)
        safeEval(expression, context, funcs) {
          try {
            // Normalize expression: convert 'and'/'or' to filtrex operators
            let expr = expression
              .replace(/\band\b/gi, ' and ')
              .replace(/\bor\b/gi, ' or ')
              .replace(/\bnot\b/gi, ' not ');

            // Compile expression with custom functions
            const filter = filtrex.compileExpression(expr, { extraFunctions: funcs });
            return Boolean(filter(context));
          } catch (e) {
            console.error('Filtrex error:', e, expression);
            return true; // Default to true on error
          }
        },
        
        // === TASK OPERATIONS ===
        createTask() {
          const tagPoints = {};
          Object.entries(this.newTask.tagPoints).forEach(([tagId, points]) => {
            if (points) tagPoints[tagId] = parseInt(points);
          });
          
          if (Object.keys(tagPoints).length === 0) {
            alert('Please assign points to at least one tag');
            return;
          }
          
          // Check if title contains recurrence pattern
          const parsed = this.parseRecurrence(this.newTask.title);

          const task = {
            id: this.generateId(),
            title: parsed.valid ? parsed.cleanTitle : this.newTask.title,
            description: this.newTask.description || '',
            status: 'active',
            tagPoints: tagPoints,
            location: { type: 'backlog' },
            createdAt: new Date().toISOString(),
            comments: [],
            sessions: [],
            skipState: null,
            recurrence: parsed.valid ? parsed.rruleString : null,
            parentId: null,
            externalSource: null,
            sprintHistory: []
          };

          this.tasks.push(task);
          this.newTask = { title: '', description: '', tagPoints: {} };
          this.showCreateTaskModal = false;
        },
        
        updateTask(task) {
          const index = this.tasks.findIndex(t => t.id === task.id);
          if (index !== -1) this.tasks[index] = { ...task };
        },
        
        completeTask(task) {
          task.status = 'completed';
          task.completedAt = new Date().toISOString();
          this.updateTask(task);
        },
        
        cancelTask(task) {
          if (confirm(`Cancel task "${task.title}"?`)) {
            task.status = 'canceled';
            task.canceledAt = new Date().toISOString();
            this.updateTask(task);
          }
        },
        
        moveTaskToSprint(task, sprint) {
          task.location = { type: 'sprint', sprintId: sprint.id };
          task.skipState = null;
          this.updateTask(task);
        },
        
        moveTaskToBacklog(task) {
          if (task.location.type === 'sprint') {
            task.sprintHistory = task.sprintHistory || [];
            task.sprintHistory.push(task.location.sprintId);
          }
          task.location = { type: 'backlog' };
          task.skipState = null;
          this.updateTask(task);
        },
        
        skipTaskForNow(task) {
          task.skipState = { type: 'for_now', skippedAt: new Date().toISOString() };
          this.updateTask(task);
        },
        
        openSkipForDayModal(task) {
          this.taskToSkip = task;
          this.skipJustification = '';
          this.showSkipForDayModal = true;
        },
        
        confirmSkipForDay() {
          if (!this.skipJustification.trim()) return;
          
          const comment = {
            id: this.generateId(),
            content: this.skipJustification,
            createdAt: new Date().toISOString(),
            updatedAt: null,
            skipJustification: true
          };
          
          this.taskToSkip.comments = this.taskToSkip.comments || [];
          this.taskToSkip.comments.push(comment);
          
          const tomorrow = new Date();
          tomorrow.setDate(tomorrow.getDate() + 1);
          tomorrow.setHours(0, 0, 0, 0);
          
          this.taskToSkip.skipState = {
            type: 'for_day',
            skippedAt: new Date().toISOString(),
            returnAt: tomorrow.toISOString(),
            justificationCommentId: comment.id
          };
          
          this.updateTask(this.taskToSkip);
          this.showSkipForDayModal = false;
          this.taskToSkip = null;
        },
        
        clearSkipState(task) {
          task.skipState = null;
          this.updateTask(task);
        },
        
        openTaskDetail(task) {
          this.selectedTask = JSON.parse(JSON.stringify(task));
          this.newCommentContent = '';
          this.showTaskDetailModal = true;
        },
        
        saveTaskDetail() {
          if (!this.selectedTask) return;
          const index = this.tasks.findIndex(t => t.id === this.selectedTask.id);
          if (index !== -1) this.tasks[index] = this.selectedTask;
        },
        
        addComment(task) {
          if (!this.newCommentContent.trim()) return;
          
          const actualTask = this.tasks.find(t => t.id === task.id);
          if (!actualTask) return;
          
          actualTask.comments = actualTask.comments || [];
          actualTask.comments.push({
            id: this.generateId(),
            content: this.newCommentContent,
            createdAt: new Date().toISOString(),
            updatedAt: null,
            skipJustification: false
          });
          
          this.selectedTask = JSON.parse(JSON.stringify(actualTask));
          this.newCommentContent = '';
        },
        
        deleteComment(task, comment) {
          const actualTask = this.tasks.find(t => t.id === task.id);
          if (!actualTask) return;
          
          actualTask.comments = actualTask.comments.filter(c => c.id !== comment.id);
          this.selectedTask = JSON.parse(JSON.stringify(actualTask));
        },
        
        spawnRecurringInstance(template) {
          const instance = {
            id: this.generateId(),
            title: template.title,
            description: template.description,
            status: 'active',
            tagPoints: { ...template.tagPoints },
            location: { type: 'backlog' },
            createdAt: new Date().toISOString(),
            comments: [],
            sessions: [],
            skipState: null,
            recurrence: null,
            parentId: template.id,
            externalSource: null,
            sprintHistory: []
          };
          
          this.tasks.push(instance);
          return instance;
        },
        
        getNextOccurrence(template) {
          if (!template.recurrence) return null;
          try {
            const rule = rrule.RRule.fromString('DTSTART:' + new Date().toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z\nRRULE:' + template.recurrence);
            return rule.after(new Date());
          } catch (e) {
            console.error('RRule error:', e);
            return new Date();
          }
        },
        
        describeRRule(rruleStr) {
          if (!rruleStr) return '';
          try {
            const rule = rrule.RRule.fromString('RRULE:' + rruleStr);
            return rule.toText();
          } catch (e) {
            return rruleStr;
          }
        },

        parseRecurrence(text) {
          if (!text || !text.trim()) {
            return { valid: false, rruleString: null, description: '', cleanTitle: text };
          }

          // Look for "every ..." pattern in the text
          const everyMatch = text.match(/\bevery\s+.+$/i);
          if (!everyMatch) {
            return { valid: false, rruleString: null, description: '', cleanTitle: text };
          }

          try {
            // Pass only the "every ..." part to fromText
            const recurrenceText = everyMatch[0];
            const rule = rrule.RRule.fromText(recurrenceText);
            const recurrenceDesc = rule.toText();

            // Remove the recurrence part from title
            const cleanTitle = text.replace(/\s*\bevery\s+.+$/i, '').trim();

            return {
              valid: true,
              rruleString: rule.toString().replace('RRULE:', ''),
              description: recurrenceDesc,
              cleanTitle: cleanTitle || text.trim()
            };
          } catch (e) {
            return { valid: false, rruleString: null, description: '', cleanTitle: text };
          }
        },
        
        // === SPRINT OPERATIONS ===
        getSprintTasks(sprint) {
          if (!sprint) return [];
          
          let tasks = this.tasks.filter(t => t.location.type === 'sprint' && t.location.sprintId === sprint.id && t.status === 'active');
          
          if (this.selectedTagFilters.length > 0) {
            tasks = tasks.filter(t => Object.keys(t.tagPoints).some(tagId => this.selectedTagFilters.includes(tagId)));
          }
          
          if (this.activeRoutine) {
            tasks = tasks.filter(t => this.evaluateTaskFilter(t, this.activeRoutine.taskFilterExpression));
          }
          
          return tasks.sort((a, b) => {
            // Returned tasks bubble to top
            if (a.skipState?.type === 'for_day' && a.skipState?.returned) return -1;
            if (b.skipState?.type === 'for_day' && b.skipState?.returned) return 1;
            // Skipped-for-day tasks go to bottom
            if (a.skipState?.type === 'for_day' && !a.skipState?.returned) return 1;
            if (b.skipState?.type === 'for_day' && !b.skipState?.returned) return -1;
            // Skipped-for-now go after normal tasks
            if (a.skipState?.type === 'for_now' && !b.skipState) return 1;
            if (b.skipState?.type === 'for_now' && !a.skipState) return -1;
            // Otherwise sort by order
            return (a.order || 0) - (b.order || 0);
          });
        },

        handleTaskReorder(itemId, newPosition) {
          const sprintTasks = this.getSprintTasks(this.selectedSprint);
          const taskIds = sprintTasks.map(t => t.id);

          // Remove from old position and insert at new
          const oldIndex = taskIds.indexOf(itemId);
          if (oldIndex !== -1) {
            taskIds.splice(oldIndex, 1);
          }
          taskIds.splice(newPosition, 0, itemId);

          // Update order values
          taskIds.forEach((id, index) => {
            const task = this.tasks.find(t => t.id === id);
            if (task) task.order = index;
          });
        },

        handleTodayReorder(itemId, newPosition) {
          const taskIds = this.todayTasks.map(t => t.id);

          // Remove from old position and insert at new
          const oldIndex = taskIds.indexOf(itemId);
          if (oldIndex !== -1) {
            taskIds.splice(oldIndex, 1);
          }
          taskIds.splice(newPosition, 0, itemId);

          // Update order values
          taskIds.forEach((id, index) => {
            const task = this.tasks.find(t => t.id === id);
            if (task) task.order = index;
          });
        },

        handleTodayReorderByDataId(item, newPosition, sortContainer) {
          // Since we don't use x-sort:item, read the new order directly from the DOM
          const container = document.querySelector('[x-sort="handleTodayReorderByDataId"]');
          if (!container) return;

          const items = container.querySelectorAll('[data-id]');
          const newOrder = Array.from(items).map(el => el.dataset.id);

          console.log('New DOM order:', newOrder);

          // Update order values on actual tasks
          newOrder.forEach((id, index) => {
            const task = this.tasks.find(t => t.id === id);
            if (task) task.order = index;
          });
        },

        getSprintLabel(index) {
          if (index === 0) return 'Current Sprint';
          if (index === 1) return 'Next Sprint';
          if (index === 2) return 'Sprint +2';
          return `Sprint ${index}`;
        },

        getSprintIcon(index) {
          if (index === 0) return 'calendar-outline';
          if (index === 1) return 'arrow-forward-outline';
          if (index === 2) return 'play-skip-forward-outline';
          return 'calendar-outline';
        },
        
        getDaysRemaining(sprint) {
          const end = new Date(sprint.endDate);
          const diff = Math.ceil((end - this.today) / (1000 * 60 * 60 * 24));
          return Math.max(0, diff + 1);
        },
        
        getSprintPointsForTag(sprint, tagId) {
          return this.tasks
            .filter(t => t.location.type === 'sprint' && t.location.sprintId === sprint.id && t.status === 'active')
            .reduce((sum, task) => sum + (task.tagPoints[tagId] || 0), 0);
        },
        
        getCapacityForTag(sprint, tagId) {
          if (sprint.capacityOverrides && sprint.capacityOverrides[tagId]) {
            return sprint.capacityOverrides[tagId];
          }
          const tag = this.getTagById(tagId);
          return tag?.defaultCapacity || 10;
        },
        
        getSprintHealth(sprint) {
          if (!sprint) return { overall: 'on_track' };
          let worstHealth = 'on_track';
          
          this.tags.forEach(tag => {
            const health = this.getTagHealth(sprint, tag.id);
            if (health === 'off_track') worstHealth = 'off_track';
            else if (health === 'at_risk' && worstHealth !== 'off_track') worstHealth = 'at_risk';
          });
          
          return { overall: worstHealth };
        },
        
        getTagHealth(sprint, tagId) {
          const assigned = this.getSprintPointsForTag(sprint, tagId);
          const capacity = this.getCapacityForTag(sprint, tagId);
          const daysRemaining = Math.max(1, this.getDaysRemaining(sprint));
          
          if (assigned === 0) return 'on_track';
          
          const burnRateNeeded = assigned / daysRemaining;
          const sustainableRate = capacity / 7;
          
          if (burnRateNeeded > sustainableRate * 1.5) return 'off_track';
          if (burnRateNeeded > sustainableRate * 1.2) return 'at_risk';
          return 'on_track';
        },
        
        getBurnRateNeeded(sprint, tagId) {
          const assigned = this.getSprintPointsForTag(sprint, tagId);
          const daysRemaining = Math.max(1, this.getDaysRemaining(sprint));
          return assigned / daysRemaining;
        },
        
        editSprintCapacity(sprint, tag) {
          this.capacityEditSprint = sprint;
          this.capacityEditTag = tag;
          this.capacityEditValue = this.getCapacityForTag(sprint, tag.id);
          this.showCapacityEditModal = true;
        },
        
        saveCapacityOverride() {
          if (!this.capacityEditSprint.capacityOverrides) {
            this.capacityEditSprint.capacityOverrides = {};
          }
          this.capacityEditSprint.capacityOverrides[this.capacityEditTag.id] = this.capacityEditValue;
          this.showCapacityEditModal = false;
        },
        
        // === SESSION OPERATIONS ===
        startSession(task) {
          if (this.activeSession) return;
          
          const session = {
            id: this.generateId(),
            taskId: task.id,
            status: 'in_progress',
            startedAt: new Date().toISOString(),
            endedAt: null,
            focusLevel: null,
            comments: []
          };
          
          const actualTask = this.tasks.find(t => t.id === task.id);
          actualTask.sessions = actualTask.sessions || [];
          actualTask.sessions.push(session);
          
          this.activeSession = session;
          this.sessionElapsed = 0;
          
          this.sessionInterval = setInterval(() => {
            this.sessionElapsed++;
          }, 1000);
          
          this.showTaskDetailModal = false;
        },
        
        openCompleteSessionModal() {
          this.sessionFocusLevel = 'neutral';
          this.sessionNote = '';
          this.markTaskComplete = false;
          this.showCompleteSessionModal = true;
        },
        
        confirmCompleteSession() {
          if (!this.activeSession) return;
          
          const task = this.getTaskById(this.activeSession.taskId);
          const session = task.sessions.find(s => s.id === this.activeSession.id);
          
          session.status = 'completed';
          session.endedAt = new Date().toISOString();
          session.focusLevel = this.sessionFocusLevel;
          
          if (this.sessionNote.trim()) {
            session.comments = [{ id: this.generateId(), content: this.sessionNote, createdAt: new Date().toISOString() }];
          }
          
          if (this.markTaskComplete) {
            this.completeTask(task);
          }
          
          this.cleanupSession();
          this.showCompleteSessionModal = false;
        },
        
        abandonSession() {
          if (!this.activeSession) return;
          
          const task = this.getTaskById(this.activeSession.taskId);
          const session = task.sessions.find(s => s.id === this.activeSession.id);
          
          session.status = 'abandoned';
          session.endedAt = new Date().toISOString();
          
          this.cleanupSession();
        },
        
        cleanupSession() {
          clearInterval(this.sessionInterval);
          this.activeSession = null;
          this.sessionElapsed = 0;
          this.sessionFocusLevel = 'neutral';
          this.sessionNote = '';
          this.markTaskComplete = false;
        },
        
        // === TAG OPERATIONS ===
        addTag() {
          if (!this.newTagName.trim()) return;
          
          this.tags.push({
            id: this.generateId(),
            name: this.newTagName,
            icon: this.newTagIcon || 'ðŸ“Œ',
            color: this.newTagColor || '#6366f1',
            defaultCapacity: this.newTagCapacity || 20,
            description: ''
          });
          
          this.newTagName = '';
          this.newTagIcon = 'ðŸ“Œ';
          this.newTagColor = '#6366f1';
          this.newTagCapacity = 20;
        },
        
        updateTag(tag) {
          const index = this.tags.findIndex(t => t.id === tag.id);
          if (index !== -1) this.tags[index] = { ...tag };
        },
        
        deleteTag(tag) {
          if (tag.id === 'untagged') {
            alert('Cannot delete the Untagged tag');
            return;
          }
          
          const tasksWithTag = this.tasks.filter(t => t.tagPoints[tag.id]);
          if (tasksWithTag.length > 0) {
            alert(`Cannot delete tag "${tag.name}" - ${tasksWithTag.length} task(s) use it`);
            return;
          }
          
          this.tags = this.tags.filter(t => t.id !== tag.id);
        },
        
        toggleTagFilter(tagId) {
          if (tagId === null) {
            this.selectedTagFilters = [];
          } else {
            const index = this.selectedTagFilters.indexOf(tagId);
            if (index === -1) {
              this.selectedTagFilters.push(tagId);
            } else {
              this.selectedTagFilters.splice(index, 1);
            }
          }
        },
        
        // === ROUTINE OPERATIONS ===
        addRoutine() {
          if (!this.newRoutineName.trim()) return;
          
          this.routines.push({
            id: this.generateId(),
            name: this.newRoutineName,
            icon: this.newRoutineIcon || 'ðŸ”„',
            color: this.newRoutineColor || '#6366f1',
            priority: this.newRoutinePriority || 5,
            taskFilterExpression: this.newRoutineFilter || 'true',
            activationExpression: this.newRoutineActivation || 'false'
          });
          
          this.newRoutineName = '';
          this.newRoutineIcon = 'ðŸ ';
          this.newRoutineColor = '#6366f1';
          this.newRoutinePriority = 5;
          this.newRoutineFilter = '';
          this.newRoutineActivation = '';
        },
        
        updateRoutine(routine) {
          const index = this.routines.findIndex(r => r.id === routine.id);
          if (index !== -1) this.routines[index] = { ...routine };
        },
        
        deleteRoutine(routine) {
          this.routines = this.routines.filter(r => r.id !== routine.id);
        },
        
        clearRoutineOverride() {
          this.manualRoutineId = '';
        },
        
        // === RESET ===
        resetAllData() {
          if (!confirm('This will delete ALL data. Are you sure?')) return;
          localStorage.removeItem('checkmate_tasks');
          localStorage.removeItem('checkmate_tags');
          localStorage.removeItem('checkmate_sprints');
          localStorage.removeItem('checkmate_routines');
          localStorage.removeItem('checkmate_settings');
          location.reload();
        }
      }
    }
  </script>
</body>
</html>
